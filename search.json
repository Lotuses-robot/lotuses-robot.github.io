[{"title":"solution-arc026_4","date":"2022-11-12T03:28:31.000Z","url":"/2022/11/12/solution-arc026-4/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"]],"categories":[["undefined",""]],"content":" arc026_4 题解 翻译： 有 nnn 个村庄，编号从 000 到 n−1n-1n−1。这些村庄通过 mmm 条道路构成一个连通图。 有一天，一场大规模的灾难摧毁了所有的道路，使得村庄之间的交通无法进行。你需要修复一些道路，将这几个村庄连接起来。 您首先估计了修理每条道路所需的费用和时间。然后计算出最低小时工资。 「小时工资」是指「修路所需费用的总和」除以「工作总时长（单位：小时）」，即 costperhour=C/Tcostperhour = C/T costperhour=C/T 请注意，不一定要修理所有的道路，也可以修理不需要的道路，只要将村庄连接起来即可。 保证图联通，且没有自环，重边。 根据题目的描述，一条边对 costperhour′costperhour&#x27;costperhour′ 的贡献的多少，可以用 C/TC/TC/T 衡量吗？ 也许，在一定程度上，是可以对比两条边的贡献。 于是，一开始我便想到一种做法，选择所有 Ci≤TiC_i \\le T_iCi​≤Ti​ 的边，剩余的边再以 C/TC/TC/T 比较跑最小生成树。 能保证正确性的一个显然的结论是：Ci≤TiC_i \\le T_iCi​≤Ti​ 的所有边总对于贡献为负。（就是能够让 costperhour′costperhour&#x27;costperhour′ 尽可能小） 但是，这显然是错的。反例：对于一条边 Ci=5,Ti=6C_i=5, T_i=6Ci​=5,Ti​=6， 10002000=0.5&lt;10052006≈0.50009\\frac{1000}{2000}=0.5&lt;\\frac{1005}{2006}\\approx0.50009 20001000​=0.5&lt;20061005​≈0.50009 为什么？有一条式子（不妨 a/b≤c/da/b\\le c/da/b≤c/d，等号同时取）： a/b≤a+cb+d≤c/da/b\\le\\frac{a+c}{b+d}\\le c/d a/b≤b+da+c​≤c/d 代入到 costperhour′costperhour&#x27;costperhour′ 的变化，同时设 costperhour′=c/tcostperhour&#x27; = c/tcostperhour′=c/t，条件是 Ci/Ti≤0C_i/T_i \\le 0Ci​/Ti​≤0（同 Ci≤TiC_i \\le T_iCi​≤Ti​）。 由于题目并未保证 c/t≥1c/t \\ge 1c/t≥1，所以有可能有 c/t&lt;Ci/Ti≤0c/t &lt; C_i / T_i \\le 0c/t&lt;Ci​/Ti​≤0。 所以有： c/t≤c+Cit+Ti≤Ci/Tic/t \\le \\frac{c + C_i}{t + T_i} \\le C_i / T_i c/t≤t+Ti​c+Ci​​≤Ci​/Ti​ 观察到 costperhour′&lt;costperhour′′costperhour&#x27; &lt; costperhour&#x27;&#x27;costperhour′&lt;costperhour′′（结果变大了，贡献非负）。 所以并不是所有 Ci≤TiC_i \\le T_iCi​≤Ti​ 的边都对贡献为负，还需要判断当前 costperhourcostperhourcostperhour 与 111 的大小关系等。 考虑到这不好维护，转换以下思路。 不能够通过 c/tc/tc/t 来判断边之间的贡献情况。注意到 n≤104n\\le10^4n≤104，可以容下 nlog⁡2kn\\log^2knlog2k。 如何将判断贡献转换为整式的判断呢？ 考虑二分最终 costperhourcostperhourcostperhour。 但是，我们如何判断一个 costperhourcostperhourcostperhour（简称为 cphcphcph） 是否能够被构造出来呢？ 由于我们的目标是判断是否能构造 cph′≤cphcph&#x27; \\le cphcph′≤cph。 cph′=c′t′cph&#x27;= \\frac{c&#x27;}{t&#x27;}cph′=t′c′​， c′t′≤cphc′≤cph⋅t′c′−cph⋅t′≤0\\frac{c&#x27;}{t&#x27;} \\le cph \\\\ c&#x27; \\le cph\\cdot t&#x27; \\\\ c&#x27; - cph\\cdot t&#x27;\\le 0 t′c′​≤cphc′≤cph⋅t′c′−cph⋅t′≤0 那么，处理为整式之后，只需要判断当前选择 c′−cph⋅t′c&#x27; - cph \\cdot t&#x27;c′−cph⋅t′ 之和是否小于等于 000即可。 通过这个变换可以将判断目标变为正负代价的简单判断。 对于每一条边，我们让 整合代价 cphi′=Ci−cph⋅Ticph_i&#x27; = C_i - cph \\cdot T_icphi′​=Ci​−cph⋅Ti​。 若 cphi′cph_i&#x27;cphi′​ 为负，必然对最终的总代价是好的（目标是非正数嘛）。 那么就可以对边按 cphi′cph_i&#x27;cphi′​ 排序，选完所有 cphi′cph_i&#x27;cphi′​ 非正的，最终对正数跑最小生成树即可！ 如果跑出的生成树结果与之前选择负数贡献边的贡献之和小于等于 000，那么必然可以构造！ 注意！这里的判断只能判断对应 cphcphcph 能否构造出更小的结果（即只能获得上下界信息），所以才只能二分。 时间复杂度：O(nlog⁡nlog⁡k),k→(106)2×104O(n\\log n \\log k), k\\to(10^{6})^2 \\times 10^4O(nlognlogk),k→(106)2×104。（eps→10−4eps\\to10^{-4}eps→10−4）"},{"title":"2022-10-26 review","date":"2022-10-26T12:26:08.000Z","url":"/2022/10/26/2022-10-26-review/","categories":[["undefined",""]],"content":"书接上回。 因为疫情的停课已经结束。还算不长把就两天还可以接受 中段考后移至 2022/10/30-31，与预期一样。 但是，有喜讯是，可以在中段考的时候继续停两天的课。 这些是小事的牢骚。 以及，昨天的校内赛。 T1：STL sort 大赛。-&gt; cmp 打假，挂 100pts T2：假做法，但是有 95pts！-&gt; 挂 5pts T3：过了 XDDD T4：根本没看 所以啊，倒数第二次考试考成这样，蓝勾~~ 以及，明天又要校内赛了。希望是信心赛。 停课两三天就结束了，文化课又开始了/ll /ll/ll/ll 离退役，还剩 2 天。"},{"title":"高斯消元法 笔记","date":"2022-10-24T02:27:51.000Z","url":"/2022/10/24/Gauss-elimination-method-Jordan/","tags":[["数学","/tags/%E6%95%B0%E5%AD%A6/"]],"categories":[["undefined",""]],"content":"例题：[NOIP2004 提高组] 虫食算 在这道题中，我们要解一个多元一次方程组，即对于 这样的数式计算，要找到所有字母对应的数值，使对于这样的 nnn 进制加法成立。每个字母对应一个数字。 很容易可以转换为方程组。问题就在于，如何解多元方程组？ P3389 【模板】高斯消元法 答案就是，高斯消元。 做法 首先，可以把一个多元方程转换为一个矩阵： [a1b1c1⋯a2b2c2⋯⋯⋯⋯⋯]\\begin{bmatrix} a_1 &amp; b_1 &amp; c_1 &amp; \\cdots \\cr a_2 &amp; b_2 &amp; c_2 &amp; \\cdots \\cr \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\end{bmatrix} ⎣⎡​a1​a2​⋯​b1​b2​⋯​c1​c2​⋯​⋯⋯⋯​⎦⎤​ 想象平时解一个多元方程时使用的方法：消元。 那么如何对一个多元方程进行消元呢？ 高斯消元选用加减消元法。 想象一个方程： \\begin{align} x_1 + x_2 = 1 \\tag{1} \\cr 2x_1 + 3x_2 = 2 \\tag{2} \\cr \\end{align} (1)−(2)×2(1) - (2) \\times 2(1)−(2)×2， x2=0(3)x_2 = 0 \\tag{3} x2​=0(3) 于是方程变为 \\begin{align} x_1 + x_2 = 1 \\tag{1} \\cr x_2 = 0 \\tag{3} \\cr \\end{align} 通过这样的变形，方程组将变成一个好看的形状——斜三角形 /kk。 观察到，在这种形状中，第 kkk 个方程中，所有 p&lt;kp &lt; kp&lt;k 的 xpx_pxp​ 系数都为 000。 这样的形状有什么用呢？ 最下方的式子形式为 knxn=qnk_nx_n = q_nkn​xn​=qn​，可以获得一组解； 通过代入的方式，倒数第二行的方程 kn−1xn−1+knxn=qn−1k_{n - 1}x_{n - 1} + k_nx_n = q_{n - 1}kn−1​xn−1​+kn​xn​=qn−1​ 由于已经知道了 xnx_nxn​ 的解，可以直接带入求 xn−1x_{n - 1}xn−1​ 的值。 通过带入和消元，最终将会把所有方程全部消干净，于是就能得到多元方程的解。 将方程化为矩阵，上面的例子可以解释为这样： [111232]\\begin{bmatrix} 1 &amp; 1 &amp; 1 \\cr 2 &amp; 3 &amp; 2 \\cr \\end{bmatrix} [12​13​12​] 对矩阵进行初等变换， 可以变成这样子 [111010]\\begin{bmatrix} 1 &amp; 1 &amp; 1 \\cr 0 &amp; 1 &amp; 0 \\cr \\end{bmatrix} [10​11​10​] 只要将矩阵化为左下角全为 000 就肯定有解了。 那么，问题就在于，如何把这一并非非常客观的过程转化为代码实现呢？ 实现 要得到一般规律，我们需要寻找一个普遍的实现，来对这个实现进行总结。 观察第一次变形。 由于倒三角形式（简化阶梯型方程组）的要求，必然有 kkk 行及之后的所有第 kkk 列之前都是 000。 比如说当 k=2k=2k=2 时，第二行及之后的所有行的第一列要求变成 000。 那么如何做到这一点呢？ 每次按顺序（从 222 开始）依次选中 kkk，对于所有 kkk 行及之后的所有行进行加减消元。 由于是依次进行消元的，所以选择第 (k−1)(k - 1)(k−1) 行进行加减消元，理由是刚好比下面所有行都多一个系数（因为 ta 在前面消元的过程中已经消掉了 k−1k - 1k−1 及之前的所有系数。如： [1312401−1−10−130−253150−5−1−9−6]\\begin{bmatrix} 1 &amp; 3 &amp; 1 &amp; 2 &amp; 4 \\cr 0 &amp; 1 &amp; -1 &amp; -10 &amp; -13 \\cr 0 &amp; -2 &amp; 5 &amp; 3 &amp; 15 \\cr 0 &amp; -5 &amp; -1 &amp; -9 &amp; -6 \\cr \\end{bmatrix} ⎣⎢⎢⎡​1000​31−2−5​1−15−1​2−103−9​4−1315−6​⎦⎥⎥⎤​ 现在已经完成了第一轮消掉 k=1k = 1k=1 的过程了。 那么如何对于第三第四行依次消掉 k=2k = 2k=2 的呢？ 选中第二行，刚好比下面都多要求保留一个系数。（在这一次中第二行不变，因为已经满足条件了） 必然可以通过乘上系数的方式使得 x2,2=x3,2x_{2, 2} = x_{3,2}x2,2​=x3,2​（这样就能通过做减法消掉系数）。 就如上面的例子，第三行乘 x2,2x3,2=−12\\frac{x_{2, 2}}{x_{3,2}} = -\\frac{1}{2}x3,2​x2,2​​=−21​，就变成了这个样子： [1312401−1−10−1301−2.5−1.5−7.50−5−1−9−6]\\begin{bmatrix} 1 &amp; 3 &amp; 1 &amp; 2 &amp; 4 \\cr 0 &amp; 1 &amp; -1 &amp; -10 &amp; -13 \\cr 0 &amp; 1 &amp; -2.5 &amp; -1.5 &amp; -7.5 \\cr 0 &amp; -5 &amp; -1 &amp; -9 &amp; -6 \\cr \\end{bmatrix} ⎣⎢⎢⎡​1000​311−5​1−1−2.5−1​2−10−1.5−9​4−13−7.5−6​⎦⎥⎥⎤​ 于是做减法。 [1312401−1−10−1300−1.58.56.50−5−1−9−6]\\begin{bmatrix} 1 &amp; 3 &amp; 1 &amp; 2 &amp; 4 \\cr 0 &amp; 1 &amp; -1 &amp; -10 &amp; -13 \\cr 0 &amp; 0 &amp; -1.5 &amp; 8.5 &amp; 6.5 \\cr 0 &amp; -5 &amp; -1 &amp; -9 &amp; -6 \\cr \\end{bmatrix} ⎣⎢⎢⎡​1000​310−5​1−1−1.5−1​2−108.5−9​4−136.5−6​⎦⎥⎥⎤​ 为什么会出现小数呢（反而上面的示例没有）？ 因为上面是手算——为了避免分数而调换了行之间的顺序（其实差不多，对于电脑来说，只不过是浮点而已）。 况且有些时候解必然是浮点数。 第四行同理，乘上 x2,2x4,2=−15\\frac{x_{2, 2}}{x_{4,2}} = -\\frac{1}{5}x4,2​x2,2​​=−51​， 变成 [1312401−1−10−1300−1.58.56.5011/59/56/5]\\begin{bmatrix} 1 &amp; 3 &amp; 1 &amp; 2 &amp; 4 \\cr 0 &amp; 1 &amp; -1 &amp; -10 &amp; -13 \\cr 0 &amp; 0 &amp; -1.5 &amp; 8.5 &amp; 6.5 \\cr 0 &amp; 1 &amp; 1/5 &amp; 9/5 &amp; 6/5 \\cr \\end{bmatrix} ⎣⎢⎢⎡​1000​3101​1−1−1.51/5​2−108.59/5​4−136.56/5​⎦⎥⎥⎤​ 做减法， [1312401−1−10−1300−1.58.56.5006/559/571/5]\\begin{bmatrix} 1 &amp; 3 &amp; 1 &amp; 2 &amp; 4 \\cr 0 &amp; 1 &amp; -1 &amp; -10 &amp; -13 \\cr 0 &amp; 0 &amp; -1.5 &amp; 8.5 &amp; 6.5 \\cr 0 &amp; 0 &amp; 6/5 &amp; 59/5 &amp; 71/5 \\cr \\end{bmatrix} ⎣⎢⎢⎡​1000​3100​1−1−1.56/5​2−108.559/5​4−136.571/5​⎦⎥⎥⎤​ 那么将会又消掉两个数！ 不断的进行下去，就可以获得解！ 还有一个问题。如果在消元的过程中出现上一行的第 kkk 个数字刚刚好为 000，那么很不走运的，这一个方程并不能用来做消元。 那么该如何调换各个方程之间的顺序，使得每一次操作的时候都有一个方程可以去加减消除掉？ 可以在对每列做消元的之前做个预处理。 对于每一个 kkk，都要保证 ak,k≠0a_{k, k} \\ne 0ak,k​​=0。 如果出现 ak,k=0a_{k, k} = 0ak,k​=0，那么就需要找一个 ak,k≠0a_{k,k} \\ne 0ak,k​​=0。 于是可以寻找 ai,k≠0,k+1≤i≤na_{i, k} \\ne 0,k + 1\\le i\\le nai,k​​=0,k+1≤i≤n。 （为什么这里 i∈[k+1,n]i \\in [k+1, n]i∈[k+1,n] 下界 为 k+1k + 1k+1 呢？因为不能够动前面的方程啊，不然前面就不满足条件了） 这时候就有聪明的小脑瓜要问了： 如果找不到呢？ 那就说明这个元 xkx_kxk​ 没有定值呗。 那就有更聪明的小脑瓜又要问了： 如果在寻找之前，已经有一个方程中有确定的 xkx_kxk​ 的系数被前面的操作调整到了数列的前面（也就是说在这个时候用不了了），到后面的时候发现没有系数为 000 的方程了，那这样又是什么情况呢？ 实际上 这玩意我也没搞太明白 XDD 反正正确性显然（ 那么，构造做法到此结束了，下面就要开始实现了。 话说 注意精度问题，判零使用 fabs(x)≤10−6\\text{fabs(x)} \\le 10^{-6}fabs(x)≤10−6。"},{"title":"2022-10-23 总结","date":"2022-10-23T11:48:16.000Z","url":"/2022/10/23/2022-10-23-review/","tags":[["总结","/tags/%E6%80%BB%E7%BB%93/"]],"categories":[["undefined",""]],"content":" 总结 2022/10/20~2022/10/23 书接上回， Codeforces 阳间比赛只打了一场。 比赛的情况还不错。AC A~D 在此总结一下做法。 Codeforces Round 829 (div.2) A. Technical Support 大概是说，要求每个 Q 之后都要有一个对应的 A。 一个 A 不能被两个 Q 所对应。 看是否能够满足这个条件。 那么可以从后往前扫，如果出现 totQ（Q 与 A 之差）&lt; 0 的情况就会爆炸。 B. Kevin and Permutation 大概是说，有一个序列 aaa，要最大化 min⁡i=1n−1∣ai+1−ai∣\\min_{i = 1} ^ {n - 1} |a_{i + 1} -a_i|mini=1n−1​∣ai+1​−ai​∣。那么观察样例 1 即可发现可以通过 n/2,n,n/2−1,n−1,⋯n / 2, n, n / 2 - 1,n - 1, \\cdotsn/2,n,n/2−1,n−1,⋯ 来构造出 min⁡=n/2\\min = n / 2min=n/2 的方案。 C1. Make Nonzero Sum (easy version) 大概意思，就是有一列数 aaa，包含 −1,1-1, 1−1,1 两种值，要选出任意个区间使得这些区间 不重复不遗漏有顺序 的覆盖整个数列，使得对于每个区间的得分之和为 000。定义区间 [l,r][l, r][l,r] 的得分为 al−al+1+al+2−al+3+⋯ara_l - a_{l + 1} + a_{l + 2} -a_{l + 3} + \\cdots a_ral​−al+1​+al+2​−al+3​+⋯ar​ 即题面所说的 “the alternating sum of all elements of the iii-th segment”（即交替和——字面理解）。 考虑只有 −1-1−1 和 111 两种值，那么无论如何改变 aia_iai​ 的符号，如果 n∤2n\\nmid 2n∤2，最终加和必然是奇数，不满足所有区间得分和为 000 的条件。所以当 n∤2n\\nmid 2n∤2 时必然无解。 那么考虑 n∣2n\\mid 2n∣2 时，如果让每一个区间和为 000，那么必然能让 s=0s = 0s=0（话说题面有隐晦地提到：“Note that each sis_isi​ does not have to be equal to zero（注意每一个 sis_isi​ 可以不为 000）, this property is about sum of sis_isi​ over all segments of partition.”）。 所以只要让每一组相邻的数构成一个字串来处理， 当 ai=ai+1a_i = a_{i + 1}ai​=ai+1​ 时，可以让区间包括这两个数，可以使一个数的符号变过来，然后相抵消。 当 ai≠ai+1a_i \\ne a_{i + 1}ai​​=ai+1​ 时，可以单独把这两个数分成两个区间单独相加（因为这样不改变符号），然后相抵消。 到最后就能全部抵消完。s=0s = 0s=0。 C2. Make Nonzero Sum (hard version) 与 C1 不同的是，这里的 aaa 可能出现 ai=0a_i = 0ai​=0。如果采取刚才的策略，000 将有可能打乱节奏，使得 aia_iai​ 与 aja_jaj​（aia_iai​ 下一个不为 000 的数）在区间的同奇偶位上。比如说 101 的情况，按照上面的策略将会使得两个 111 直接相加，打乱节奏。 但是注意到 000 作为一个空数，他可以起到过渡作用。 首先有一个结论，非 000 数个数为奇数必为 -1。（理由同理） 那么现在就考虑让所有非 000 数个数为偶数的情况都有解。 想到可以与上一道题类似的做法，两两相抵消。但是有部分过程会稍有区别。 若 ai≠aja_i \\ne a_jai​​=aj​，这种情况比较简单。对于上一道题来说，这两个数可以分别取，然后相互抵消。但是中间可能参杂 000，由于 000 不会影响到结果，所以可以把所有 000 放在一起统一抵消（或者你想单独给他们分组也行）。那么再分别取即可。 若 ai=aja_i = a_jai​=aj​，对于上一道题来说，这两个要放在同一子序列中相互抵消。但是有个问题。如果中间参杂了 000，可能会影响到互相抵消。那么可以想到一种构造方法：101 -&gt; 1|01 这样分组分配，让最后一个 000 与后面的非 000 数相抵消，那么必然有解。再比如 1000001 -&gt; 100000|01，前面 111 为正不变符号，后面 111 在第二个数字上，变号，那么就可以相互抵消了。 那么， D. Factorial Divisibility 如题所名，这道题分析阶乘的整除性质。 有数列 aaa，要判断 x!x!x! 是否是 ∑ai!\\sum{a_i!}∑ai​! 的因数。 那么可以想到一个很明显的结论：对于 ai≥xa_i \\ge xai​≥x 的数可以不用考虑，因为本身就有了 x!x!x! 的因数。 然后根据玄学的思考，其他的 ai!a_i!ai​! 可以相互合并获得 (ai+1)!(a_i + 1)!(ai​+1)!。比如说 1!+1!=2!,2!+2!+2!=3!1! + 1! = 2!,2! + 2! + 2 ! = 3!1!+1!=2!,2!+2!+2!=3! 其中的规律是 i!⋅(i+1)=(i+1)!i! \\cdot (i + 1)= (i + 1)!i!⋅(i+1)=(i+1)! 。所以通过一次次的合并可以合并到 xxx 就不用再合并了。 在合并的过程中如果出现剩余的情况，那么说明该组数据不能整除：因为剩下的 a!&lt;x!a!&lt;x!a!&lt;x!，必然不是倍数关系。无论如何必须都要全部组合在一起才能说明是 ok 的。 以上是 Codeforces 的分析。 吐槽 Luogu S 模拟赛。 由于早于 Codeforces 1.5h，我思考了第一题并成功的想出了逆序对的做法——即要求为 yi=yj,xi1&lt;xj1,xi2&gt;xj2y_i = y_j,x^1_i&lt;x^1_j,x^2_i &gt; x^2_jyi​=yj​,xi1​&lt;xj1​,xi2​&gt;xj2​，的两颗导弹就会碰撞。 但是做到 15:00 就没有打了。T1 也没实现（否定了自己）。有些小遗憾，这次模拟赛如果打满暴力将可以冲进前 50。但是没关系， Codeforces 有进步！ 这里是 T1 的部分实现代码 已经实现了记录是哪一个位置上的导弹提供的贡献。但是遗憾没有继续做下去。 先逃—— 由于疫情，停课了，三天啊 三天啊 而且中段考有可能后移导致我也得参加，这样我亏死啦"},{"title":"2022-10-20 总结","date":"2022-10-20T10:47:16.000Z","url":"/2022/10/20/2022-10-20-review/","tags":[["总结","/tags/%E6%80%BB%E7%BB%93/"]],"categories":[["undefined",""]],"content":" 总结 2022/10/17~2022/10/20 书接上回， ARC 掉大分： T1 晚切，T2 思路假掉，心态崩掉——/dk 做题重心： Luogu 部分特殊算法题 + sf 的洛谷题单； 思考一点 Codeforces Problems。 比赛： 校内赛 2022/10/18： 水题复现赛。 T1 是大贪心；； T2 是大矩阵快速幂；； T3 是状压 DP； T4 —— emm—— DP；； 怎么说吧， T1 贪心稳定发挥。 T2 矩阵快速幂取模了——但是没有开 long long 乘法溢出（以后只用 #define int long long 了 /dk）pts 100 -&gt; 30。 T3 实数输入—— 没有看题，直接读入了整数 pts 100 -&gt; 0。 T4 没打完—— pts100 -&gt; 0。 然后垫底。 铜锭思彤啊！ 校内赛 2022/10/20： 难题汇聚赛。 T1 玄学贪心 竟然没挂； T2 神奇树上倍增—— 没调完 pts100 -&gt; 0 （说句闲话，下午调到四点才调完 对了一下午大数据，眼睛快瞎了）； T3 玄学二分—— 暴力都没打； T4 （？？？）； 然后再次垫底。。 铜锭斯通啊！ 总体表现： 还需更加细心啊 做题还要更快一点 ：（（（ 下周有一个 Codeforces 阳间 div2，加油上分！） new"},{"title":"P4343 题解","date":"2022-10-19T11:59:15.000Z","url":"/2022/10/19/Solution-P4343/","tags":[["题解","/tags/%E9%A2%98%E8%A7%A3/"],["二分","/tags/%E4%BA%8C%E5%88%86/"]],"categories":[["undefined",""]],"content":"Problem Link 这一道二分，非常的经典（ 首先，可以在 O(l)O(l)O(l) 的时间内，计算出定值 nnn 对应切了多少道题目。 那么就可以二分 nnn，每次 check 计算出的 k′k&#x27;k′ 与原 kkk 的大小关系，并由此二分。 上下界之间只有一个等号的不同，是一样的（ 坑点： 输出 -1 只用一个。 l=1,r=1014l = 1,r =10^{14}l=1,r=1014。 开 long long。 "},{"title":"2022-10-16 总结","date":"2022-10-16T11:12:03.000Z","url":"/2022/10/16/2022-10-16-review/","tags":[["总结","/tags/%E6%80%BB%E7%BB%93/"]],"categories":[["undefined",""]],"content":" 停课记录： 2022/10/12~2022/10/16 做题中心： Codeforces Constructive problem *1400 - *1800 Luogu NOIP Problem + CSP Problem 比赛： 校内赛 on 2022/10/13，全员挂科。 T1 是滚动数组优化，但是空间压得很紧。 实际上这道题我花了大于 2 hour，非常不应该。 T2 找规律，但没时间做 /oh luogu 月赛 on 2022/10/16， T1，T2 过水，T3 难度爆炸，T4 不能理解其 Sub3/5。 T3 最终想出做法，离结束还有 2hour。今天晚上实践完成。 ABC 掉大分 ARC —— ？ 下周主要还是向思维题进攻。~~经过严密的分析，~~CSP 常考思维题。 加油——"},{"title":"数论及莫比乌斯反演学习","date":"2022-10-15T01:12:50.000Z","url":"/2022/10/15/number-theory-and-mobius-studies/","tags":[["数学","/tags/%E6%95%B0%E5%AD%A6/"]],"categories":[["undefined",""]],"content":"话说我的数论和数学已经不够我现在用了，随便做点题都要推式子，不如先学一下有什么要学的———方便做题。 数论基础 首先必然是余数。 余数在数论中出现的频次（也许）最多了。 带余除法 b=qa+r,d≤r&lt;∣a∣+db = qa+r,d\\le r&lt;|a| + db=qa+r,d≤r&lt;∣a∣+d （ddd 是常数，一般不考虑 aaa 正负，以下也不考虑） 一般取余都会带入 d=0d = 0d=0，即 0≤r&lt;a0 \\le r &lt; a0≤r&lt;a。 还有一种特殊余数（绝对最小余数），d=⌊a/2⌋d = \\lfloor a/2 \\rfloord=⌊a/2⌋，即 −⌊a/2⌋≤r&lt;⌈a/2⌉-\\lfloor a/2 \\rfloor \\le r &lt; \\lceil a/2 \\rceil−⌊a/2⌋≤r&lt;⌈a/2⌉​ （话说要取整吗 数论基础 - OI Wiki (oi-wiki.org) 这里没有取整） 性质 唯一性：这个 rrr 在区间内唯一。 充分性：连续取 aaa 个整数构成的剩余系是完全的。 最大公约数和最小公倍数 没什么好讲的； 辗转相除法 / 辗转相减法：欧拉定理； 高精度 gcd / lcm： 要让最终时间复杂度为 Θ(nlog⁡2n)\\Theta(n\\log_{2}n)Θ(nlog2​n)， 辗转相减法 + 二的因数优化：O(log⁡2n)O(\\log_2n)O(log2​n) 高精度加减 &amp; 高精除单精： O(n)O(n)O(n)。 注意！ 如果使用辗转相减法会使算法变为 O(n2log⁡n)O(n^2\\log n)O(n2logn)（高精度除法为 O(n2)O(n^2)O(n2)）。 高精度送分题： P2152 [SDOI2009] SuperGCD Python Code 算数基本定理 （没听过，但显然） 引理：设 ppp 是素数，p∣a1a2p \\mid a_1a_2p∣a1​a2​，那么 p∣a1p \\mid a_1p∣a1​ 和 p∣a2p \\mid a_2p∣a2​ 至少有一个成立。 定理：设正整数 aaa，必有： a=p1p2p3⋯psa = p_1 p_2 p_3 \\cdots p_s a=p1​p2​p3​⋯ps​ 其中 pjp_jpj​ 是素数，且唯一（不计次序）。 以及，合并相同的 pjp_jpj​，得到因式分解式： a=p1α1p2α2⋯ ,p1&lt;p2&lt;⋯a=p_1^{\\alpha_1} p_2^{\\alpha_2}\\cdots, p_1 &lt; p_2 &lt; \\cdots a=p1α1​​p2α2​​⋯,p1​&lt;p2​&lt;⋯ 同余 a≡b(modk)a \\equiv b \\pmod ka≡b(modk) 表示 a mod k=b mod ka \\bmod k = b \\bmod kamodk=bmodk。 式中的 bbb 是 aaa 对模 mmm 的剩余，这个概念与余数完全一致。通过限定 bbb 的范围，相应的有 aaa 对模 mmm 的最小非负剩余、绝对最小剩余、最小正剩余。 性质（抄过来啦） From OI-Wiki 自反性：a≡a(modm)a\\equiv a\\pmod ma≡a(modm)。 对称性：若 a≡b(modm)a\\equiv b\\pmod ma≡b(modm)，则 b≡a(modm)b\\equiv a\\pmod mb≡a(modm)。 传递性：若 a≡b(modm),b≡c(modm)a\\equiv b\\pmod m,b\\equiv c\\pmod ma≡b(modm),b≡c(modm)，则 a≡c(modm)a\\equiv c\\pmod ma≡c(modm)。 线性运算：若 a,b,c,d∈Z,m∈N∗,a≡b(modm),c≡d(modm)a,b,c,d\\in\\mathbf{Z},m\\in\\mathbf{N}^*,a\\equiv b\\pmod m,c\\equiv d\\pmod ma,b,c,d∈Z,m∈N∗,a≡b(modm),c≡d(modm) 则有： a±c≡b±d(modm)a\\pm c\\equiv b\\pm d\\pmod ma±c≡b±d(modm)。 a×c≡b×d(modm)a\\times c\\equiv b\\times d\\pmod ma×c≡b×d(modm)。 若 a,b∈Z,k,m∈N∗,a≡b(modm)a,b\\in\\mathbf{Z},k,m\\in\\mathbf{N}^*,a\\equiv b\\pmod ma,b∈Z,k,m∈N∗,a≡b(modm), 则 ak≡bk(modmk)ak\\equiv bk\\pmod{mk}ak≡bk(modmk)。 若 a,b∈Z,d,m∈N∗,d∣a,d∣b,d∣ma,b\\in\\mathbf{Z},d,m\\in\\mathbf{N}^*,d\\mid a,d\\mid b,d\\mid ma,b∈Z,d,m∈N∗,d∣a,d∣b,d∣m，则当 a≡b(modm)a\\equiv b\\pmod ma≡b(modm) 成立时，有 ad≡bd( mod md)\\dfrac{a}{d}\\equiv\\dfrac{b}{d}\\left(\\bmod\\;{\\dfrac{m}{d}}\\right)da​≡db​(moddm​)。 若 a,b∈Z,d,m∈N∗,d∣ma,b\\in\\mathbf{Z},d,m\\in\\mathbf{N}^*,d\\mid ma,b∈Z,d,m∈N∗,d∣m，则当 a≡b(modm)a\\equiv b\\pmod ma≡b(modm) 成立时，有 a≡b(modd)a\\equiv b\\pmod da≡b(modd)。 若 a,b∈Z,d,m∈N∗a,b\\in\\mathbf{Z},d,m\\in\\mathbf{N}^*a,b∈Z,d,m∈N∗，则当 a≡b(modm)a\\equiv b\\pmod ma≡b(modm) 成立时，有 gcd⁡(a,m)=gcd⁡(b,m)\\gcd(a,m)=\\gcd(b,m)gcd(a,m)=gcd(b,m)。若 ddd 能整除 mmm 及 a,ba,ba,b 中的一个，则 ddd 必定能整除 a,ba,ba,b 中的另一个。 数论函数 OI Wiki (oi-wiki.org)：「数论函数指定义域为正整数的函数。数论函数也可以视作一个数列。」 积性函数 重点—— 定义 若函数（数论函数）f(n)f(n)f(n) 满足 f(1)=1f(1) = 1f(1)=1，∀x,y∈N∗,gcd⁡(x,y)=1\\forall x, y \\in \\mathbf{N^*},\\gcd(x,y)=1∀x,y∈N∗,gcd(x,y)=1 都有 f(xy)=f(x)∗f(y)f(xy) = f(x) * f(y)f(xy)=f(x)∗f(y)，那么 f(x)f(x)f(x) 为积性函数。 一定要满足 f(1)=1f(1) = 1f(1)=1 吗？ 若对于 ∀x,y∈N∗\\forall x,y\\in\\mathbf{N^*}∀x,y∈N∗ 都有 f(xy)=f(x)∗f(y)f(xy) = f(x) * f(y)f(xy)=f(x)∗f(y) ，那么 f(x)f(x)f(x) 为完全积性函数。 性质 积性函数的传递性： 若 f(x)f(x)f(x) 与 g(x)g(x)g(x) 都为积性函数，那么以下函数也是积性函数： h(x)=f(xp)h(x)=fp(x)h(x)=f(x)⋅g(x)h(x)=∑d∣xf(d)⋅g(xd)\\begin{aligned} h(x) &amp;= f(x ^ p) \\\\ h(x) &amp;= f^p(x) \\\\ h(x) &amp;= f(x) \\cdot g(x) \\\\ h(x) &amp;= \\sum_{d\\mid x}f(d) \\cdot g(\\frac{x}{d}) \\end{aligned} h(x)h(x)h(x)h(x)​=f(xp)=fp(x)=f(x)⋅g(x)=d∣x∑​f(d)⋅g(dx​)​ 应用： 设 x=∏pikix = \\prod p_i ^ {k_i}x=∏piki​​，（此处 pip_ipi​ 是质数吗？分解质因式） 若 F(x)F(x)F(x) 为积性函数，则有 F(x)=∏F(piki)F(x) = \\prod F(p_i^{k_i})F(x)=∏F(piki​​)。 若 F(x)F(x)F(x) 为完全积性函数，则有 F(x)=∏Fki(pi)F(x) = \\prod F^{k_i}(p_i)F(x)=∏Fki​(pi​) 其中第二条与第一条区别在于乘方的位置！ 例子（常用数论函数 /se \\varepsilon =&gt; ε\\varepsilonε 单位函数：ε(n)=[n=1]\\varepsilon(n) = [n = 1]ε(n)=[n=1]； 提示 在狄利克雷卷积中，f∗ε=ε∗f=ff * \\varepsilon = \\varepsilon * f = ff∗ε=ε∗f=f。 Prove it. 恒等函数： id⁡k(n)=nk\\operatorname{id}_k(n)=n^kidk​(n)=nk（id⁡(n)=n\\operatorname{id}(n) = nid(n)=n； 常数函数：1(n)=11(n) = 11(n)=1； \\sigma =&gt; σ\\sigmaσ 除数函数：σk(n)=∑d∣ndk\\sigma_{k}(n) = \\sum_{d\\mid n} d^kσk​(n)=∑d∣n​dk，kkk 是常数。k=0k = 0k=0 时函数记为 d(n)d(n)d(n)，k=2k = 2k=2 时记为 σ(n)\\sigma(n)σ(n)。 \\phi =&gt; ϕ\\phiϕ 欧拉函数：ϕ(n)=∑i=1n[gcd⁡(i,n)=1]\\phi(n) = \\sum _ {i = 1} ^ n [\\gcd(i, n) = 1]ϕ(n)=∑i=1n​[gcd(i,n)=1]​。 提示 ∑d∣nϕ(d)=n\\sum_{d \\mid n}\\phi(d) = n d∣n∑​ϕ(d)=n Prove it. \\mu =&gt; μ\\muμ 莫比乌斯函数：μ(n)={1n=10∃d&gt;1,d2∣n(−1)ω(n)otherwise\\mu(n)=\\begin{cases}1&amp;n=1\\\\0&amp;\\exists d&gt;1,d^{2}\\mid n\\\\(-1)^{\\omega(n)}&amp;\\text{otherwise}\\end{cases}μ(n)=⎩⎪⎨⎪⎧​10(−1)ω(n)​n=1∃d&gt;1,d2∣notherwise​，其中 ω(n)\\omega(n)ω(n) 表示 nnn 的本质不同质因子个数：加性函数 。[1] 加性函数 此处加性函数指数论上的加性函数 (Additive function)。对于加性函数 fff，当整数 a,ba,ba,b 互质时，均有 f(ab)=f(a)+f(b)f(ab)=f(a)+f(b)f(ab)=f(a)+f(b)。 应与代数中的加性函数 (Additive map) 区分。 莫比乌斯反演 前置知识：数论分块、狄利克雷卷积。 狄利克雷卷积 定义 设 f(x),g(x)f(x),g(x)f(x),g(x) 为数论函数。 (f∗g)(n)=∑xy=nf(x)⋅g(y)(f * g)(n) = \\sum_{xy = n} f(x) \\cdot g(y)(f∗g)(n)=∑xy=n​f(x)⋅g(y) 或 (f∗g)(n)=∑d∣nf(d)⋅g(nd)(f * g)(n) = \\sum _ {d \\mid n} f(d) \\cdot g(\\frac{n}{d})(f∗g)(n)=∑d∣n​f(d)⋅g(dn​) （感觉后面那个式子更好看 /kk） More? 可以形象的理解为 将 nnn 分为两个数乘积，将两个数分别带入 f(x),g(x)f(x), g(x)f(x),g(x) ，乘积之和为结果。 逆 f∗g=εf * g = \\varepsilon f∗g=ε 结论： g(n)=1f(1)(ε−∑i∣n,i≠1f(i)g(ni))g(n) = \\frac{1}{f(1)}\\left(\\varepsilon - \\sum_{i \\mid n, i \\ne 1}f(i)g(\\frac{n}{i})\\right) g(n)=f(1)1​⎝⎛​ε−i∣n,i​=1∑​f(i)g(in​)⎠⎞​ 证明 f∗g=∑d∣nf(d)⋅g(nd)=∑d∣n,d≠1f(d)⋅g(nd)+f(1)⋅g(n)=εf(1)⋅g(n)=ε−∑d∣n,d≠1f(d)⋅g(nd)g(n)=1f(1)(ε−∑d∣n,d≠1f(d)⋅g(nd))\\begin{aligned} f * g &amp;=\\\\ \\sum_{d \\mid n} f(d) \\cdot g\\left(\\frac{n}{d}\\right) &amp;=\\\\ \\sum_{d \\mid n, d \\ne 1} f(d) \\cdot g\\left(\\frac{n}{d}\\right) +f(1) \\cdot g(n) &amp;= \\varepsilon \\\\ f(1) \\cdot g(n) &amp;= \\varepsilon -\\sum_{d\\mid n,d \\ne 1} f(d) \\cdot g\\left(\\frac{n}{d}\\right) \\\\ g(n) &amp;= \\frac{1}{f(1)}\\left(\\varepsilon -\\sum_{d\\mid n,d \\ne 1} f(d) \\cdot g\\left(\\frac{n}{d}\\right)\\right) \\end{aligned} f∗gd∣n∑​f(d)⋅g(dn​)d∣n,d​=1∑​f(d)⋅g(dn​)+f(1)⋅g(n)f(1)⋅g(n)g(n)​===ε=ε−d∣n,d​=1∑​f(d)⋅g(dn​)=f(1)1​⎝⎛​ε−d∣n,d​=1∑​f(d)⋅g(dn​)⎠⎞​​ 性质 如果 f,gf,gf,g 是积性函数，则 f∗gf * gf∗g 也是积性函数； 其实这个性质在积性函数性质章节提到过—— 是在狄利克雷卷积下，它长这样：(f∗g)(a)∗(f∗g)(b)=(f∗g)(ab)(f* g)(a) * (f* g)(b) = (f* g)(ab)(f∗g)(a)∗(f∗g)(b)=(f∗g)(ab)。 其他性质看这里——算法学习笔记(35): 狄利克雷卷积 - 知乎 (zhihu.com) 莫比乌斯函数 定义[2] μ\\muμ 为莫比乌斯函数，定义为 μ(n)={1n=10n 含有平方因子(−1)kk 为 n 的本质不同质因子个数\\mu(n)= \\begin{cases} 1&amp;n=1\\\\ 0&amp;n\\text{ 含有平方因子}\\\\ (-1)^k&amp;k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\\\ \\end{cases} μ(n)=⎩⎪⎨⎪⎧​10(−1)k​n=1n 含有平方因子k 为 n 的本质不同质因子个数​ 详细解释一下： 令 n=∏i=1kpicin=\\prod_{i=1}^kp_i^{c_i}n=∏i=1k​pici​​，其中 pip_ipi​ 为质因子，ci≥1c_i\\ge 1ci​≥1。上述定义表示： n=1n=1n=1 时，μ(n)=1\\mu(n)=1μ(n)=1； 对于 n≠1n \\ne 1n​=1 时： 当存在 i∈[1,k]i\\in [1,k]i∈[1,k]，使得 ci&gt;1c_i &gt; 1ci​&gt;1 时，μ(n)=0\\mu(n)=0μ(n)=0，也就是说只要某个质因子出现的次数超过一次，μ(n)\\mu(n)μ(n) 就等于 000； 当任意 i∈[1,k]i\\in[1,k]i∈[1,k]，都有 ci=1c_i=1ci​=1 时，μ(n)=(−1)k\\mu(n)=(-1)^kμ(n)=(−1)k，也就是说每个质因子都仅仅只出现过一次时，即 n=∏i=1kpin=\\prod_{i=1}^kp_in=∏i=1k​pi​，{pi}i=1k\\{p_i\\}_{i=1}^k{pi​}i=1k​ 中个元素唯一时，μ(n)\\mu(n)μ(n) 等于 −1-1−1 的 kkk 次幂，此处 kkk 指的便是仅仅只出现过一次的质因子的总个数。 性质 ∑d∣nμ(d)=ε(n)\\sum_{d\\mid n}\\mu(d)=\\varepsilon(n)∑d∣n​μ(d)=ε(n)，μ∗1=ε\\mu * 1 = \\varepsilonμ∗1=ε。其中 ε={1n=10n≠1\\varepsilon = \\begin{cases}1&amp;n=1\\\\0&amp;n\\neq 1\\\\\\end{cases}ε={10​n=1n​=1​ 。 证明：二项式定理。 反演性质 [gcd(i,j)=1]=∑d∣gcd(i,j)μ(d)[gcd(i,j) = 1] = \\sum_{d \\mid gcd(i, j)} \\mu(d) [gcd(i,j)=1]=d∣gcd(i,j)∑​μ(d) 莫比乌斯变换 设 f(n),g(n)f(n), g(n)f(n),g(n)。 形式 1 若 f(n)=∑d∣ng(d)f(n) = \\sum_{d \\mid n} g(d)f(n)=∑d∣n​g(d)，则 g(n)=∑d∣nμ(d)f(nd)g(n) = \\sum_{d \\mid n} \\mu(d)f(\\frac{n}{d})g(n)=∑d∣n​μ(d)f(dn​)。 莫比乌斯变换 可以看作 ggg 与 111 做卷积：(g∗1)(n)=∑d∣n1(nd)∗g(d)(g * 1)(n) = \\sum_{d \\mid n} 1(\\frac{n}{d}) * g(d)(g∗1)(n)=∑d∣n​1(dn​)∗g(d)。 证明 卷积： 已知 f=g∗1f = g * 1f=g∗1，证明：g=f∗μg = f * \\mug=f∗μ。 f∗μ=g∗μ∗1f * \\mu = g * \\mu * 1f∗μ=g∗μ∗1。 (1∗μ)(n)=∑d∣nμ(nd)(1 * \\mu)(n) = \\sum_{d \\mid n} \\mu(\\frac{n}{d})(1∗μ)(n)=∑d∣n​μ(dn​)， 设 n=1n = 1n=1： ∑d∣nμ(nd)=μ(1)=1\\sum_{d \\mid n} \\mu(\\frac{n}{d}) = \\mu(1) = 1∑d∣n​μ(dn​)=μ(1)=1 设 n≠1n \\ne 1n​=1： d=p1c1p2c2⋯pkckd = p_1 ^ {c_1} p_2 ^ {c _ 2} \\cdots p_k ^ {c_k}d=p1c1​​p2c2​​⋯pkck​​ 根据莫比乌斯函数的定义， ∑d∣nμ(d)\\sum_{d \\mid n} \\mu(d)∑d∣n​μ(d) 这条式子在只有 ci≤1c_i \\le 1ci​≤1 的时候才会对式子有影响。 总共 kkk 个因数，所以 (1∗μ)(n)=∑i=0k(ki)(−1)i=(−1+1)k=0(1 * \\mu)(n) = \\sum_{i = 0} ^ {k} \\dbinom{k}{i}(-1) ^ i = (-1 + 1) ^ k = 0 (1∗μ)(n)=i=0∑k​(ik​)(−1)i=(−1+1)k=0 所以 (1∗μ)(n)=[n=1]=ε(1 * \\mu)(n) = [n = 1] = \\varepsilon(1∗μ)(n)=[n=1]=ε。 所以 f∗μ=gf * \\mu = gf∗μ=g。 证毕。 形式 2 f(n)=∑n∣dg(d)f(n) = \\sum_{n \\mid d} g(d)f(n)=∑n∣d​g(d)，那么 g(n)=∑n∣dμ(dn)(d)g(n) = \\sum_{n \\mid d} \\mu(\\frac{d}{n})(d)g(n)=∑n∣d​μ(nd​)(d)。 例题 P2568 GCD 题目的要求： ∑i=1n∑j=1n[gcd⁡(i,j)∈prime]\\sum_{i = 1} ^ n \\sum_{j = 1} ^ n [\\gcd(i,j) \\in \\text{prime}] i=1∑n​j=1∑n​[gcd(i,j)∈prime] 变形： ∑p∈prime∑i=1n∑i=1n[gcd⁡(i,j)=p]\\sum_{p \\in \\text{prime}} \\sum_{i = 1} ^ n \\sum_{i = 1} ^ n [\\gcd(i, j) = p] p∈prime∑​i=1∑n​i=1∑n​[gcd(i,j)=p] 再变： ∑p∈prime∑i=1⌊np⌋∑j=1⌊np⌋[gcd⁡(i,j)=1]\\sum_{p \\in \\text{prime}} \\sum_{i = 1} ^ {\\lfloor\\frac{n}{p}\\rfloor} \\sum_{j = 1} ^ {\\lfloor\\frac{n}{p}\\rfloor} [\\gcd(i, j) = 1] p∈prime∑​i=1∑⌊pn​⌋​j=1∑⌊pn​⌋​[gcd(i,j)=1] 令 i≥ji \\ge ji≥j，在 i=ji = ji=j 时重复，所以 −1-1−1。 ∑p∈prime(∑i=1⌊np⌋(2⋅∑j=1i[gcd⁡(i,j)=1])−1)\\sum_{p \\in \\text{prime}} \\left(\\sum_{i = 1} ^ {\\lfloor\\frac{n}{p}\\rfloor} \\left(2 \\cdot \\sum_{j = 1} ^ i [\\gcd(i, j) = 1] \\right) - 1 \\right) p∈prime∑​⎝⎛​i=1∑⌊pn​⌋​(2⋅j=1∑i​[gcd(i,j)=1])−1⎠⎞​ 再变： ∑p∈prime(∑i=1⌊np⌋2⋅ϕ(i)−1)\\sum_{p \\in \\text{prime}} \\left(\\sum_{i = 1} ^ {\\lfloor\\frac{n}{p}\\rfloor} 2 \\cdot \\phi(i) - 1 \\right) p∈prime∑​⎝⎛​i=1∑⌊pn​⌋​2⋅ϕ(i)−1⎠⎞​ 观察到中间的 ∑\\sum∑ 可以前缀和掉， 做 ϕ\\phiϕ 的前缀和然后爆搜即可。 线性筛 phi Solution P2568 据说 LuoguP9157 逝莫反，等 WBWYX 大蛇做出来去请教一下。 Update by 2023/03/20 数论基础 - OI Wiki ↩︎ 莫比乌斯反演 - OI Wiki ↩︎ "},{"title":"浅谈机（J）惨（C）技巧——从入门到精通(?)","date":"2022-07-29T07:58:36.000Z","url":"/2022/07/29/qian-tan-J-C-ji-qiao-cong-ru-men-dao-jing-tong/","categories":[["undefined",""]],"content":"JC总是无聊的机房中有意思的一个瞬间。。。 比如： 这个杰作由 ZSWBWYX 完成 你认为这只是AK-IOI吗？不！注意用户名。。。也是此人的杰作。 所以，在险恶的机房里，一定要保护好自己的账号。 知己知彼方能百战百胜 ，下面我就来介绍下JC的各种方法。 windows篇 （1）线下物理攻击 要点： 抓住时机，看准时间。比如说： A去上了个厕所 。 B开始了JC，他打开了A电脑的浏览器，点开了Luogu。 他快速地在讨论区里打了“I AK IOI”的字样。 此时，C帮助B锁住了门。 等到B完成他的工作时，A刚好回来，就被C挡在了门外。 C放A进来，B已经退出了A的账号。（这使A登录删除的速度减缓不少） 完美！ 这就是上图的来源。B就是ZSWBWYX，此人今天被别人JC 解决方案： 注意上厕所的时机，在离开电脑时记得锁定账户。 还要搞好同学关系 （2）线上各路工具 这里举几个例子。(笑) [1] JC Tools 通过远程服务器端响应，实现类似Telnet功能。 要点： 要提前给A开好电脑，装上JC Tools 服务器端。 记得不要把自己的表情显示出来！（我就被识破过。。。） [2] 直接用Telnet 这里不再多说。 （3）自己动手，丰衣足食 通过自己做的钩子，识别键盘按键，通过记录键盘来获取密码 要点： 技术含量要求高，推荐易语言 （非广告） 小心提防各种程序Bug，以防对方发现被JC。 要提前做好（2）的操作，给对方装上记录装置。 小心走火入魔，忘记学OI！ 例子： 。。。算了伤心往事不提了 Windows篇总结 只要注意好线下JC，加上小心警惕，就足够提防了！ Linux篇 Linux主要用于线下Linux环境比赛。 不过这里仅做技术汇报，建议不要用在大型比赛，小心被查。 对于公示期间收到的举报，CCF NOI科学委员会调查后判定选手HN-0117（Karry5307）的2题分数为0，省选结果相应变化。 （1）官方工具攻击 说起远程连接，肯定是ssh啦！ 不过再说一遍：警告：请勿在正式比赛中使用！您将会被禁赛三年的风险。 首先你要懂得Linux-Bash基础指令。 最主要指令： ssh aaa@192.168.xxx.xxx aaa☞用户名。 登录后，你需要熟练使用vim、cat等命令行工具，对其代码进行操作。 比如 1、用cat显示别人的代码然后自己改改，A掉 2、删除别人的代码，用心险恶 3、帮别人复制一个板子进去，赛后举报 4、帮别人改动一下，于是MLE/TLE/CE/RE 再说一遍：警告：任意一项都会让您面临被禁赛三年的风险。 还有scp指令，与ssh类似，只不过不需要登录命令行。请读者自行查资料。 对于那些利用SSHJC的人，你可以这样做 （1）若你发现了确切证据，保留日志，赛后举报。 日志在这里：~/.bash_history （2）若怕发生被JC事件却没被发现，你可以：pkill sshd 或 拔网线 补：sshd就是ssh的服务端 （3）反其道而行之 算了，会面临被举报风险。（逃） 这里附上大佬Karry5307的JC经历 请勿模仿！"},{"title":"P1687 机器人小Q 题解","date":"2022-07-29T07:58:28.000Z","url":"/2022/07/29/solution-p1687/","categories":[["undefined",""]],"content":"我看这题似乎没有将状态转移方程讲清楚的题解啊，所以我来了 入题。 看到这题，我立马想到贪心。 对题意，我的错误的理解为：对于任意一个能量菜单上的能量值都可以在任意时间充电。这样，就可以直接排序选前kkk个最小值进行充电。 然后，我看到了此题的颜色：普及+/提高 这题不简单！ 于是，我就看到了讨论中的： 贪心60分求助 算法疑问 是题目问题还是我的问题 哦原来是 按一定顺序 给出了 NNN 个单位的能量值，使用也得 按一定顺序 。也就是说，用了第 iii 个后，第 iii 个之前的就不能再用了。 好了，排序不能用了，决策题只能考虑动态规划了。 于是设 f[i][j]f[i][j]f[i][j] 表示在第 iii 个之前使用了 jjj 种能量值时最少用的天数。 比如说对于样例， f[3][2]f[3][2]f[3][2] 表示第三个能量值之前的三种能量值1,119,119中要选择两个能量值并充电给小Q。 考虑 iii 和 jjj 之间关系。 若 i==j 若 i=ji=ji=j ，也就是说前 iii 个一定要全部选，那么第 iii 项也一定要选。那么就考虑选择第 iii 个： f[i][j]=f[i−1][j−1]+(t[i−1][j−1]+num[i]&gt;119)?1:0f[i][j]=f[i-1][j-1]+(t[i-1][j-1]+num[i]&gt;119)? 1:0f[i][j]=f[i−1][j−1]+(t[i−1][j−1]+num[i]&gt;119)?1:0 看起来那么长，其实就是将一个if嵌在其中。 首先， f[i−1][j−1]f[i-1][j-1]f[i−1][j−1] 指前一个选择了 j−1j-1j−1 项的状态，到此状态是刚好选择 jjj 项。 而后面的一个三元运算，则指是否需要重新的一天来充电——用题目的话来说就是充电量超过了119，则要用另一天来充电。否则小Q就要原地爆炸 注： ttt 数组保存着在第 iii , jjj 状态时那一天已经用了多少能量； 若 i&gt;j 再考虑 i&gt;ji&gt;ji&gt;j 。这表示在前 iii 种能量值中只用选择 jjj 个，而并不用全部选完。这就又分两种情况： （1）不选第 iii 种能量。 （2）选第 iii 种能量。 对于（2），在 i=ji=ji=j 时我们已经讨论过了，那么只需要Ctrl-C+V就好了。 对于（1），直接 f[i][j]=f[i−1][j]f[i][j]=f[i-1][j]f[i][j]=f[i−1][j] 就得了，没啥要考虑的。 只要对比（1）和（2）的大小就OK了。 依照上面的思路，我们可以写出这个简单的代码。 （不要着急复制粘贴AC这道题啊，因为下面的代码只有30分） 好，为什么30分呢？等等， i&gt;ji&gt;ji&gt;j 的情况没考虑完整！若选择和不选择的天数相同呢？ 先停一下，看看 f[i][j]f[i][j]f[i][j] 的含义。它表示在第 iii 个之前使用了 jjj 种能量值时最少用的天数（的向下取整）。对啊！这使当前这一天的使用的能量没有发挥作用啊！ 还是举个粒子吧。 现在已经使用了这样的能量组合： 118 1 50 到第三天时，用了1天并还剩下50的能量。剩下的50能量便是主要要对比的对象了。 那么，天数相同时，最后一天所用的能量肯定越少要好啊！所以，在天数相同的情况下，就选择最后一天使用能量较少得那一种方案。 于是代码变成了这样： 完结。 等等？为什么没有“You can’t do it.”都可以的？ 哈哈哈，这说明了一些显而易见的事实。 既然想到了那么就说一说怎么判断吧。如何凑出不可能充k种电的情况呢？ 只有一种情况，就是没有足够的方式充电。 那么输入就可以改成这样： 正式完结。 有不懂得问题，问我哈 有错误请指出，方便我改进自身qwq"},{"title":"P1172 安全逃离 题解","date":"2022-07-29T07:58:21.000Z","url":"/2022/07/29/solution-p1172/","categories":[["undefined",""]],"content":"数据点望 Luogu 能完善下 好，讲解正式开始。 拿到正确题目后，能想到的就是模拟、暴力。虽然这是一道普及的题目，我们也要将代码优化得更加 短小精干。 我们要模拟啥呢？ 1、首先，对于每一个牛，我们都要检查他能不能离开。 对于每一个牛，它上方格子或右方格子中，一定要有一条完全没有其他牛。 就说上文的样例。444 号上方有 111 号，向上走行不通。同时有房还有 666 号，向右走，也行不通。所以这头牛就不能安全逃出。 同样我们可以看出，要让整个图安全，只要去掉 111，444，666 的任意一个，就可以解决纠纷了。 2、其次，如果不是安全的图，我们要尝试去掉每一个牛，来尝试能否使图变得安全。 这里，我似乎想到一个优化的方法，就是将发生冲突的牛记录下来，在去牛的时候只检查这些就够了。 可惜数据太小，也没太大用，这里只起抛砖引玉的效果。 用上面这两条足以通过此题。 上代码！ 时间复杂度：O(n2)O(n^2)O(n2) 有啥问题？留言问我。 jr 的第二篇题解 awa cnt = 2"},{"title":"P7774 KUTEVI 题解","date":"2022-07-29T07:58:13.000Z","url":"/2022/07/29/solution-p7774/","categories":[["undefined",""]],"content":"写这篇题解花了我很多不少时间，希望能过 awa 题意： 有 mmm 个数，这 mmm 个数能否由另外 nnn 个数通过加减运算获得。 对于每一次加减的操作，结果不能小于 000（角度不能小于 000）； 对于大于等于 360360360 的结果，对 360360360 取模。（大于 360∘360^{\\circ}360∘ 的角会转一圈后继续转） 能则输出 YES ，不能则输出 NO 。 思路： dp\\texttt{dp}dp（背包）、搜索都可以。dp 太难想 这里我只讲搜索。 对于每一个状态，只有加和减两种状态。所以只需要对每一个状态枚举每一个数的加或减。 记录已经过状态，枚举中遇到了要获得的数，就表明可以实现。枚举结束后还没有遇到，则不能实现。 实现： 对于状态 xxx ， 拓展 (x±a[i]) mod 360(x\\pm a[i]) \\bmod 360(x±a[i])mod360 且 x±a[i]≥0x\\pm a[i]\\ge0x±a[i]≥0 且未被拓展过。 上代码！ 完结。 对于可以不枚举 x−ax-ax−a 的证明： 对于任意正整数 xxx，aaa，kkk，ppp，证明： (x+ak) mod 360=x−ap(x+ak) \\bmod 360 = x-ap(x+ak)mod360=x−ap。 xxx 指某一状态。意思就是，只用加 kkk 次 aaa 就可以枚举到 x−apx-apx−ap。 原式可转化为： 360t+x−ap=x+ak360t+x-ap=x+ak360t+x−ap=x+ak，ttt 为任意正整数。 化简，得：360t=a(p+k)360t=a(p+k)360t=a(p+k)。 所以，只需证明 a(p+k)a(p+k)a(p+k) 恒为 360360360 倍数。 若 aaa 为 360360360 倍数，得证； 若 aaa 不为 360360360 倍数， 则若使 (p+k)(p+k)(p+k) 为 360360360 倍数，k=360−pk=360-pk=360−p 即可。 又有 x−ap≥0x-ap\\ge0x−ap≥0，则 p≤xa&lt;360p\\le \\frac{x}{a}&lt;360p≤ax​&lt;360。 则 kkk 在满足 k=360−pk=360-pk=360−p 的条件下满足 k&gt;0k&gt;0k&gt;0，所以无论 ppp 取多少都能满足 (p+k)(p+k)(p+k) 为 360360360 倍数。得证。 综上，(x+ak) mod 360=x−ap(x+ak) \\bmod 360 = x-ap(x+ak)mod360=x−ap。 第一次自己写 OI 证明题，有不对或不完善的地方请指出，谢谢qaq； 被打回x4 – 求过！"},{"title":"P7767 DNA 题解","date":"2022-07-29T07:58:06.000Z","url":"/2022/07/29/solution-p7767/","categories":[["undefined",""]],"content":"虽然我似乎解释明了贪心是可行的，但是我还是有些不爽 dp 做更直观吧 Solution 入手这道题，看了看，就直接奔去写贪心。 至于如何贪心？ 题目大意：对于每一个操作有两种操作选择，使终串全为 A\\texttt{A}A 。 对于这道题，贪心只考虑局部最优解，不能影响到其他位置 于是，就有两种情况要讨论： 单独的 B 对于单独出现的 B\\texttt{B}B， 执行方法 1 需要 1 步，即直接修改（操作 1）。并且不会对字符串造成其他影响。 执行方法 2 需要 2 步，才能使字符串不会出现变化。 比如说：AABAA\\texttt{AABAA}AABAA 在位置3执行操作2，BBAAA\\texttt{BBAAA}BBAAA （操作 2） 再在位置2执行操作2，AAAAA\\texttt{AAAAA}AAAAA （操作 2） 显然，当出现单独的 B\\texttt{B}B 时，执行方法 1 改变单个字符更优。 连续的一串 B 对于出现一串的 BBBB......\\texttt{BBBB......}BBBB...... 执行方法 1 需要执行 ∣S∣|S|∣S∣ 步，SSS 为全 B\\texttt{B}B 子串。 执行方法 2 需要执行 2 步，与 “单独的 B”中考虑一样。 由于 ∣S∣≥2|S| \\ge 2∣S∣≥2，所以，在出现连续的 B\\texttt{B}B 串时，执行方法 2 更优于方法 1。 综上，需要不影响其他步骤，从右往左扫； 单独的 B\\texttt{B}B 就直接修改； 连续的 b\\texttt{b}b 就通过方法 2 改变（其实第二次操作没必要进行，因为执行结束后会继续往前扫，自然会继续改变）。 上代码！ 还有更好的贪心思路要告诉我啊 qaq。"},{"title":"P7755 POREDAK 题解","date":"2022-07-29T07:57:58.000Z","url":"/2022/07/29/solution-p7755/","categories":[["undefined",""]],"content":"其实这道题渟水的 Solution 题意简化： 在一堆字符串中间，找到一些两两相对位置正确的字符串的个数。 其实，我们可以给这些字符串标号。 就比如说，按样例 1， 对正确序列标号为 1,2,31,2,31,2,3。 就可以将给出的序列变成 1,3,21,3,21,3,2。 于是就只用寻找正确的编号大小关系即可。 可以在上面序列中找到两组： (1,3)(1,3)(1,3) 和 (1,2)(1,2)(1,2)。于是答案就是 2/32/32/3。 最后变成了找逆序对正序对的问题。 实现： map\\texttt{map}map 编号，再用 for\\texttt{for}for 枚举就可以啦~ 虽然可以用归并排序解逆序对，但时间复杂度不需要。 qaq"},{"title":"CSP初赛考点汇总","date":"2022-07-29T07:57:51.000Z","url":"/2022/07/29/CSP-ChuSai-KaoDian/","categories":[["undefined",""]],"content":"非广告：csdn的博客 东西太多，luogu列表不太友好(没有有标题链接，不便寻找） qwq 为SCP初赛选手（我）收集的各种定理qwq 更新： 1、为了初赛都能用，不限于定理了 2、主旨为在短时间内复习各算法，备初赛 3、请确定你学习（学懂了）了 oi\\texttt{oi}oi 的基础知识。 可能会一直更新下去qwq 最新：2021/9/11 10:03 1、主定理 在求某一分治（递推？）算法时间复杂度中适用。 规模为 nnn 的问题通过分治，得到 aaa 个规模为 nb\\dfrac{n}{b}bn​ 的问题，每次递归带来的额外计算为 O(nd)O(n^d)O(nd) 即 T(n)=aT(nb)+O(nd)T(n)=aT(\\dfrac{n}{b})+O(n^d)T(n)=aT(bn​)+O(nd)。 求执行 T(n)T(n)T(n) 的时间复杂度。 定理： 若 a=bda=b^da=bd，T(n)=O(ndlog⁡n)T(n) = O(n^d \\log{n})T(n)=O(ndlogn) 若 a&lt;bda&lt;b^da&lt;bd，T(n)=O(nd)T(n) = O(n^d)T(n)=O(nd) 若 a&gt;bda&gt;b^da&gt;bd，T(n)=O(nlog⁡ba)T(n) = O(n^{\\log_ba})T(n)=O(nlogb​a) 套就完事儿了 证明请bdfs 2、等比数列 指一个数列所有数有公共比。 比如：111，222，444，888，......... 此时公比为 222。 等比数列通项公式为 an=a1⋅qn−1a_n=a_1\\cdot q^{n-1} an​=a1​⋅qn−1 a1a_1a1​ 即为数列首项，qqq 就是公比。 比如说，求上面那个等比数列的第五个数。 a5=1×(25−1)a_5=1\\times (2^{5-1})a5​=1×(25−1) 求得 a5=16a_5=16a5​=16。 根据通项公式，我们可以轻松得到前 nnn 项的求和公式。 Sn=a1(qn−1)q−1(q≠0,q≠1)S_n=\\dfrac{a_1(q^n-1)}{q-1} (q\\neq 0,q\\neq 1) Sn​=q−1a1​(qn−1)​(q​=0,q​=1) 还是比如：求上面那个数列的前五项之和。 S5=1×(25−1)2−1S_5=\\dfrac{1\\times (2^5-1)}{2-1}S5​=2−11×(25−1)​ 求得 S5=31=1+2+4+8+16S_5=31=1+2+4+8+16S5​=31=1+2+4+8+16。 至于推导嘛，它来了！ 2.1 等比数列求和公式推导 首先，先将通项公式列出来。 Sn=∑i=1na1⋅qi−1S_n=\\sum_{i=1}^na_1\\cdot q^{i-1} Sn​=i=1∑n​a1​⋅qi−1 提 a1a_1a1​。 Sn=a1⋅∑i=1nqi−1S_n=a_1\\cdot \\sum_{i=1}^nq^{i-1} Sn​=a1​⋅i=1∑n​qi−1 添一个 (q−1)(q-1)(q−1)。 Sn=a1(q−1)⋅∑i=1nqi−1q−1S_n=\\frac{a_1(q-1)\\cdot \\sum_{i=1}^nq^{i-1}}{q-1} Sn​=q−1a1​(q−1)⋅∑i=1n​qi−1​ 乘开， Sn=a1(∑i=2n+1qi−1−∑i=1nqi−1)q−1S_n=\\frac{a_1(\\sum_{i=2}^{n+1}q^{i-1}-\\sum_{i=1}^nq^{i-1})}{q-1} Sn​=q−1a1​(∑i=2n+1​qi−1−∑i=1n​qi−1)​ 消掉一大堆， Sn=a1(qn−q0)q−1S_n=\\frac{a_1(q^n-q^0)}{q-1} Sn​=q−1a1​(qn−q0)​ 此时要求 q≠0q\\neq 0q​=0 且 q≠1q\\neq 1q​=1 最终得到 Sn=a1(qn−1)q−1(q≠0, q≠1)S_n=\\frac{a_1(q^n-1)}{q-1} (q\\neq 0,\\,q\\neq 1) Sn​=q−1a1​(qn−1)​(q​=0,q​=1) 应用嘛，其实很广的。 2.2 应用：h层满k叉树求节点个数 第 000 层 k0k^0k0 个； 第 111 层 k1k^1k1 个； 第 222 层 k2k^2k2 个； 第 333 层 k3k^3k3 个； … 第 hhh 层 khk^hkh 个。 这不就等比数列吗。上求和公式！ N=kh+1−1k−1N=\\dfrac{k^{h+1}-1}{k-1}N=k−1kh+1−1​ 注意！ 这里其实有 h+1h+1h+1 层，所以为什么是 h+1h+1h+1。 题目链接：Noip2018提高 - 第四题 3、贪心 贪心算法（英语：greedy algorithm），是用计算机来模拟一个 “贪心”的人 做出决策的过程。这个人十分贪婪， 每一步行动总是按某种指标选取最优的操作。 而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。 可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。 ——Copy by OI-WIKI 从中可以看出，贪心所讲究的，是思维的 贪度和正确，二者一样重要。 （贪度，即为贪心的层次，越贪心，贪度越高 我瞎掰扯的， 理解就好） 首先，贪度的提高并不是一次思考就能完成的。 就好比时间复杂度需要一步步优化。 贪心的主要内容，证明等皆在OI-Wiki中有讲述，可以到oi-wiki找到详细的讲述。 4、二分 二分，可以理解为分成两半。在二分基础应用中，二分是用来在一 有序 数列中寻找数的快速方法。 注：必须有序！ 比如，V={1,2,3,3,5}V=\\{1,2,3,3,5\\}V={1,2,3,3,5} 我需要在 VVV 中寻找第一个比 aaa 大于（等于）的数。 比如说 a=3a=3a=3，则找到的数下标为 333。 4.1 基本实现 1、令 l=1,r=∣V∣.\\texttt{l}=1,\\texttt{r}=|V|.l=1,r=∣V∣. 2、又令 mid=(l+r)/2.\\texttt{mid}=(l+r)/2.mid=(l+r)/2. 3、对于 VmidV_{mid}Vmid​， 若 Vmid≤aV_{mid}\\leq aVmid​≤a，因为整体有序，所以 aaa 一定在 mid\\texttt{mid}mid 左边（或它本身）。 这里等于号放在这里，是因为即使等于了，第一个说不定还在前面。 若 Vmid&lt;aV_{mid}&lt; aVmid​&lt;a，同理，aaa 一定在 mid\\texttt{mid}mid 右边。 持续进行步骤二和步骤三，当 l=rl=rl=r 时，就找到了。 这就是最基本的实现。 实现代码：（arr为有序序列） 4.2 进阶实现 首先，二分一般实现于最值最化。 简化最值最化的要求： 1、答案在一个固定区间内； 2、查找不容易，判断容易（比如说找数）； 3、可行解对于区间满足一定的单调性。 如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 ，不满足看做 ，至少对于这个条件的这一维度是有序的） 这就是指某一个数组的左边 或 右边都满足某一条件，即单调性 可以理解为上上上上面的例子中， V[3] 左边都满足小于 3 这个条件。 4.3 实际应用 见二分答案 5、三分（待填坑） 6、哈希 对于初赛来说，只需理解哈希函数以及哈希碰撞即可。 哈希列表的概念是差不多的 哈希函数 &amp; 哈希碰撞 简单来说，就是将某一难处理的数值、字符串通过某一处理函数处理成简单的数字。 看例子就可以学懂了： 设哈希函数为：H(x)=⌊x/5⌋H(x)=\\lfloor x/5\\rfloorH(x)=⌊x/5⌋， 则 111 的哈希值为 H(1)=0H(1)=0H(1)=0，222 的哈希值也为 H(2)=0H(2)=0H(2)=0。 此时 111 和 222 的哈希值相同，有同样的哈希值保存，会导致碰撞，称为哈希碰撞 7、KMP（待填坑） 放OI-Wiki\\texttt{OI-Wiki}OI-Wiki链接。 8、最小生成树（待填坑） 放OI-Wiki\\texttt{OI-Wiki}OI-Wiki链接。 9、最短路 这里只讲 Floyd，Dijkstra，SPFA 提醒： 除了 Floyd 算法以外，都建议使用邻接表。邻接矩阵时间复杂度为O(n^2)，等同于没优化 9.1 Floyd 时间复杂度：O(n3)O(n^3)O(n3) 评价：最简单的最短路算法，最高的时间复杂度，最划算的多源最短路。 注意事项：中间节点k一定要放在最外层，至于后果，需按数据手推（ 思路：一一枚举每两个点的最短路。 样例代码： 9.2 Dijkstra 时间复杂度： 在稀疏图中，使用二叉堆实现的 Dijkstra 法的 O((n+m)log⁡n)O((n+m)\\log n)O((n+m)logn) 即 O(mlog⁡n)O(m\\log n)O(mlogn) 较 Bellman-Ford (SPFA) 算法的 O(nm)O(nm)O(nm) 具有较大的效率优势； 而在稠密图中，这时候使用暴力做法 O(n2+m)O(n^2+m)O(n2+m) 较二叉堆实现更优。 但一般只使用优先队列法 O(mlog⁡m)O(m\\log m)O(mlogm) ，代码最清晰简短，但时间复杂度在稀疏图上比二叉堆略差。 评价：十分经典的单源最短路，在单源最短路中时间复杂度最强，但不能处理负环。各种方法形成不同的时间复杂度，容易考到。 注意事项：不能处理负环！ 思路：推荐这篇博客 样例代码： 对于上面 vector&lt;edge&gt; e[maxn]，是邻接表的一种实现，内存消耗是动态的，并且最方便，但时间复杂度 可能 偏高。 9.3 SPFA 时间复杂度：随机数据中表现优秀，但平均时间复杂度为 O(nm)O(nm)O(nm)。 评价：最好理解的最短路，最容易Cu卡爆的最短路。 注意事项：能处理负环。 思路：有点类似BFS，是BF的队列优化版本。 样例代码： -by oi-wiki 10、位运算 这位大佬的博客 写的不好，勿喷"},{"title":"Radioactive 题解","date":"2022-07-29T07:57:43.000Z","url":"/2022/07/29/radioactive-ti-jie/","categories":[["undefined",""]],"content":"这道题还是很水的，做了三天才做出来 Solution 一看区间操作，就是线段树。 不过虽然说着简单，但是细节有很多，请注意这里讲到的每一个细节。 解题思路 观察下放操作，先是升序，再是降序。 若是直接下放，会出现很多复杂的情况，比如说，原来的序列被切分成 1,⋯ ,k,k−11,\\cdots ,k,k-11,⋯,k,k−1 的情况。这样就要处理很多特殊情况。 经验告诉我们， 操作可以分解为一次上升，一次点修改，一次下降。 即： 1,⋯ ,k−2,k−1,k−0,k−1,k−2,⋯ ,11,\\cdots ,k-2,k-1,k-0,k-1,k-2,\\cdots ,1 1,⋯,k−2,k−1,k−0,k−1,k−2,⋯,1 变为 1,⋯ ,k−11,\\cdots ,k-11,⋯,k−1 与 k−1,⋯ ,1k-1,\\cdots ,1k−1,⋯,1 和剩下的 kkk 的操作。 单独操作，每一个下方操作都是单调的，没有特殊情况。 对于 lazy\\texttt{lazy}lazy ，我们保存两个 vector\\texttt{vector}vector，分别用来记录下放的上升和下降。 每一次分配 lazy\\texttt{lazy}lazy 直接使用等差数列求和公式求和即可。最坏时间复杂度为 O(T2log⁡n)O(T^2\\log n)O(T2logn)。 这里之所以说是 T2T^2T2，是因为每一次下放的操作都会遍历之前的所有 lazy\\texttt{lazy}lazy 操作，肯定可以卡到 T2T^2T2。况且空间复杂度为 O(nk)O(nk)O(nk)。绝对需要优化。 优化 注意到就是 lazy\\texttt{lazy}lazy 的下放导致时空爆掉，所以我们重点攻克 lazy\\texttt{lazy}lazy 的下放和记录操作。 在一节数学课前，我找到了灵感： 等差数列有个不知道是不是定理的真命题，即两组长度相同的等差数列，每个数一一对应相加时，得到的等差数列，首项为两组等差数列的首项之和，末项也是末项之和，同样的，公差也是两公差之和。 至于证明，很简单嘛（ 然后，我们就发现，每次 lazy\\texttt{lazy}lazy 记录的长度都是固定的，即 r−l+1r-l+1r−l+1 。 所以，我们只需要记录并累加首项，末项和公差即可。 时间复杂度降为 O(Tlog⁡n)O(T\\log n)O(Tlogn) （可能带点大系数，我不想优化了）；空间复杂度降为 O(n)O(n)O(n)。 细节 1 aaa 和 bbb 有可能为负数，稍微加个数就好了 2 下放的时候一定要按照区间划分好的 lll 和 rrr 来划分，否则有可能划错。 3 在下放时，只需要保留在 aaa 和 bbb 区间内的修改就好了。 第一行两个整数 a,b,Ta,b,Ta,b,T，表示你负责的区间在 [a,b][a,b][a,b] ，共有 TTT 组事件发生。 不会有人没看到吧 4 就没啥了 ，都是我粗心错的小错误 Code 完结撒花qwq"},{"title":"UVA144 Student Grants 题解","date":"2022-07-29T07:57:35.000Z","url":"/2022/07/29/solution-uva144/","categories":[["undefined",""]],"content":"Long time no write, Please pass it over!!! Solution 最近都在刷水题，就看到了这道水题 模拟题，只要读懂都会做qwq 题意即为：一堆学生去取钱，取的钱数按照顺序，成递增的序列，为 1,2,3,⋯ ,k1,2,3,\\cdots,k1,2,3,⋯,k 元。 取第 iii 次钱的学生将会取到 (i−1) mod (k)+1(i-1) \\bmod(k)+1(i−1)mod(k)+1 元。 若是某一个同学取完了 404040 元，则他就会退出取钱的队伍，就是说，取完钱了。 要是取多了前，即取得钱数大于 404040 元，则多出 404040 元的钱给下一个排队的同学，并且下一个同学回到队尾。 举个栗子， 有 333 个同学，分别取了： [39,38,37][39,38,37] [39,38,37] 元钱。此时，最前面的同学可以取 101010 元钱，那么钱数就会变为 [49,38,37][49,38,37] [49,38,37] 第一个同学取完了所有钱，将多出来的钱给后面的同学，并离开队伍。 [40(leaved),47,37][40(\\texttt{leaved}),47,37] [40(leaved),47,37] 队列就变成了 [47,37][47,37] [47,37] 下一个同学本来要回到队列尾端，但是由于 47&gt;4047&gt;4047&gt;40 ，所以他也可以离开队列了。 [40(leaved),44][40(\\texttt{leaved}),44] [40(leaved),44] 就变成了 [44][44] [44] 此时，所有同学都可以离开队伍，结束所有过程 所以，就可以枚举每一个同学取的钱数，加上队列模拟，就可以k掉了。 code "},{"title":"P7541 DOBRA 题解","date":"2022-07-29T07:57:24.000Z","url":"/2022/07/29/solution-p7541/","categories":[["undefined",""]],"content":" solution 题意简化 一个字符串，将所有的 _ 替换成大写字母，使结果字符串符合要求： 1、不包含三个连续 元音 或 辅音 字母； 2、字符串中至少有一个 L 。 求最终字符串可能的个数。 看到这道题，即想到了万能的算法——搜索。 从下标 000 开始，枚举每一个字母。 由于每次枚举的字母与后面的枚举无关，所以这样搜索不会出现重复的终串。 在枚举结束时使用 check 检测是不是合法终串，如果是就是一种情况。 可惜，只会拿到可怜的 30%30\\%30% 的分数。 先来算算时间复杂度吧。 对于每次操作，都有每个 _ 需要枚举 262626 次，同时最多有 101010 位，所以枚举次数最少 261026^{10}2610 次方，超时是稳稳的。 所以如何减少时间复杂度呢？ 我们可以发现，这道题实际上**辅音字母之间并没有区别。**同理，对于元音字母也是如此。 所以，可以每次只枚举两次，对于辅音字母的结果乘 26−5=2126-5=2126−5=21；元音字母的结果乘 555。 还有一点要注意，由于 L 会影响结果，所以需要特殊考虑。 总共 333 次，枚举次数降为 3103^{10}310 ，AC 稳稳的。 AC Code： 从 9 s 降到 30ms，质的提升啊！ 哦。"},{"title":"P7542 MALI","date":"2022-07-29T07:57:17.000Z","url":"/2022/07/29/solution-p7542/","categories":[["undefined",""]],"content":"又双叒叕水了一篇题解… 题目简述 对于两个序列 A，序列 B，长度一致； 共 nnn 次操作， 每次操作都会向这两个序列增加数字。 在每次操作后，要求对每个序列中的每个数字配对，要让配对数之和的最大值最小。 Solution 贪心。 对每时每刻的序列排序，aaa 中从小到大与 bbb 中从大到小配对。 证明： 对于序列中最小的 aia_iai​，序列最大的bjb_jbj​， 若将 aia_iai​ 替换成 aka_kak​ 且 ak&gt;aia_k&gt;a_iak​&gt;ai​ ，此时必有 ak+bj&gt;ai+bja_k+b_j&gt;a_i+b_jak​+bj​&gt;ai​+bj​，不必原计划更优； 若将 bjb_jbj​ 替换成 bkb_kbk​，且 bj&lt;bkb_j&lt;b_kbj​&lt;bk​，则必有 az&gt;aia_z&gt;a_iaz​&gt;ai​ 需要与 bjb_jbj​ 配对。所以必有更大值 az+bj&gt;ai+bja_z+b_j&gt;a_i+b_jaz​+bj​&gt;ai​+bj​，也不必原计划更优。 所以，每次选择最小和最大的配对可以得到最优解。 可惜直接排序时间复杂度不够。 时间复杂度为 O(n2log⁡n)O(n^2\\log n)O(n2logn)，n≤105n\\leq 10^5n≤105，超时。 优化。 1、桶优化 发现 1≤ai,bj≤1001\\leq a_i,b_j\\leq 1001≤ai​,bj​≤100，所以考虑直接桶排。 时间复杂度降为 O(n2)O(n^2)O(n2)。 2、连续配对优化 发现当 ai,bja_i,b_jai​,bj​ 出现多次时，会直接配出 min⁡(ai,bj)\\min(a_i,b_j)min(ai​,bj​) 组一样的配对。 所以对于桶中 ai,bja_i,b_jai​,bj​ ，每次配对时，对应减少 min⁡(ai,bj)\\min(a_i,b_j)min(ai​,bj​) 即可。 最坏时间复杂度为 O(100n)O(100n)O(100n) ，不会超时。 AC Code qwq"},{"title":"玄学优化之——快读","date":"2022-07-29T07:57:09.000Z","url":"/2022/07/29/xuan-xue-you-hua-zhi-kuai-du/","categories":[["undefined",""]],"content":"对于基础读入读出，有基本的快读： 根据这个基本快读，结合不定参数，可以得到加强版 reads 和 writes。 reads 支持多参数； writes 支持多参数，且输出格式为 &quot;%d %d ... %d \\n&quot; 注： 请注意格式，以及不要用错了。"},{"title":"抄题解 题解","date":"2022-07-29T07:57:02.000Z","url":"/2022/07/29/chao-ti-xie-ti-xie/","categories":[["undefined",""]],"content":" Solution 观察题面，由数据范围可知这道题的复杂度为 O(n log n) 作法为贪心。 如何贪心呢？ 在与 @ryanright 的交锋往中，认识到一点他的做题技巧： 1、能做的题先做； 2、做不了的选择最高收益的做。 所以，就能通过优先队列写出下面的代码： 不过这是否正确呢？ 证明： 1、优先做能做的（能力值范围内的）是必须的。 能做的，不会降低能力（注意 x,y≥0x,y\\geq 0x,y≥0），且之后的题目会有更高的收益。 2、做不了能做的，就做收益最高的，也是必须的。 没有能做的，就代表不一定会增加能力。当增加为正时，相对于其他题目，会让后面有更多的收益；增加为负时，相对于其他题目，会让后面做的题扣的能力更少。 /kk"},{"title":"Good 博客收集栏","date":"2022-07-29T07:56:53.000Z","url":"/2022/07/29/Good-bo-ke-shou-ji-lan/","categories":[["undefined",""]],"content":"如题。 图论 并查集 算法学习笔记(1) : 并查集 “按秩合并”并未看完 "},{"title":"NOIP2021 退役记","date":"2022-07-29T07:56:46.000Z","url":"/2022/07/29/noip2021-tui-yi-ji/","categories":[["undefined",""]],"content":" Day -114514 考完 csp，心态比较炸裂，有点恢复不起来，然后听说 noip 有机会去玩，心态好了一些。于是就等了等，最后我提高三等奖也能蹭个名额，就准备足了去玩一玩。 于是…就十分离谱的去参加了 noip2021。 Day 1 早晨 6:30 就起来了，困得要命，晚上又没睡好，就有点困；7 点去了学校，结果他们都比我早。 坐车去了 zsjz，在等待的时候面基了其他一些小学同学奆老，来虐菜，其中一个据说最后两百多分。 就草草的开始了比赛。比赛的键盘空格有坑，有时候按下去敲不出空格来，然后监考老师态度很好，不给换之类的。幸好后来习惯了。 刚开始，打了个快读，看第一题，开始的想法是打暴力，再看一遍，诶，线性筛经典题目，直接上正解。 大约花了 10 分钟，搞定第一题； 第二题，打暴力； 第三题，想了想，打暴力； 第四题，花了两个小时打暴力 ，结果没分。 最后大约检查了 30 分钟，硬是查出了一堆问题，顺便写了个作文。 前面两排中看到有人在颓 dino，似乎已经打到了几千分了，瞬间起了 Orz 之心。 于是，noip就这么结束了。 不想写了/qq"},{"title":"P7964 Kaučuk 题解","date":"2022-07-29T07:56:39.000Z","url":"/2022/07/29/solution-p7964/","categories":[["undefined",""]],"content":"好久没有写题解了，社贡掉的太低了，就来写入门题解了 Solution 观察题面，大模拟。 模拟思路，是维护三个变量 f,s,tf,s,tf,s,t，分别代表一级标题序号，二级标题序号以及三级标题序号。 −1-1−1 代表到上一个父标题没有同级标题。 设当前的状态为标题的级别， 比如 这样，在前三个时三个状态都为 111，第四个标题时状态为 222，第五个标题时状态为 333。 在插入新标题时， 若当前状态对应的变量为 −1-1−1，那么就要插入新的标题。这时，让这个状态变量设置为 111，表示当前级标题序号为 111。 若当前状态对应的变量不为 −1-1−1，那么说明前面有相同级别的标题，需要在后面接一个新序号的标题，那么这个变量就自增 111。 操作完成后，直接输出三个序号即可。 举个例子： 执行第四步时，需要在原来基础上增加一层标题，那么就要令 ttt 等于 111。 执行第五步时，层数掉回了一级，那么在他之上就没有二级和三级标题了，就让 sss 和 ttt 都设为 −1-1−1，fff 自增 111。 Code "},{"title":"UVA10966 3KP-BASH Project Sol.","date":"2022-07-29T07:56:31.000Z","url":"/2022/07/29/solution-uva10966/","categories":[["undefined",""]],"content":"啊…太坑了 我放弃了 为了让后人不再掉坑，我在这里将刘汝佳在《算法竞赛入门经典——训练指南》中的翻译打出来。 （为了加强严密性，题目文字根据官方数据进行了增删） 你的任务是为一个假想的 3KP 操作系统编写一个简单的 Bash 模拟器。 由于操作系统本身还没有写完，你暂时需要在模拟器的内存中虚拟出一个文件系统，而不是和真是的文件系统交互。 下面介绍 3KP 操作系统中的文件系统。 文件（file）是数据存储的最小单位。文件名有英文字母（大小写敏感）、数字和点（.）组成，但不能包含两个连续的点，且用户创建的文件名不能是单个的点字符（即 . ）。 文件名长度不能超过 255255255，文件大小不能超过 2632^{63}263。一个文件可能具有 directory 属性和 hidden 属性。 目录（directory） 是一个大小为 000，具有 directory 属性的文件，里面可以保存任意数量的文件（无论属性）。 空文件系统只有一个文件，叫做“根目录”。在任意时刻，有一个称为“当前目录”的目录。Bash 启动时，当前目录就是根目录。 指令中引用文件的时候，可以使用绝对路径和相对路径。 绝对路径以字符“/”开头，如“/home/acm/uva”；相对路径不以字符“/”，当前目录和父目录分别用“.”和“…”表示。 如当前目录为“/home/acm/uva”，那么“…/…/…/home/…”就是根目录。 这里展示访问的过程： 你的 Bash 模拟器需要支持 888 个命令，具体如下： （没有 [] 标志的参数为必选参数） （又：Markdown 表格不支持回车，只能直接打了 qwq) 1. cd path 改变当前目录。path 可以是相对路径，也可以是绝对路径。 如果目录不存在或名字不合法，输出 path not found 2. touch filename [-size] [-h] 修改文件。 filename 应由两部分组成，前一部分是目录（为空就是当前目录），后一部分为文件名。 比如： 都是合法的。 其中的文件名应当是合法的文件名，否则输出 bad usage（见后）。其中的目录应当是当前文件系统中存在的目录，否则输出 path not found。 在正常情况下，同名文件（如果有的话），应当先被删除，然后新建文件。 文件的大小由 -size 参数决定（若没有参数 -size 默认为 0），参数 -h 表示创建隐藏文件。用户不会制定多个 -size 参数。 如果存在一个同名的目录，输出 a directory with the same name exists。 3. mkdir path [-h] 与 touch 类似。 创建目录。 path 应由两部分组成，前一部分是目录（为空就是当前目录），后一部分为新建目录名。 其中要新建的目录名应当是合法的目录名，否则输出 bad usage。其中的目录应当是当前文件系统中存在的目录，否则输出 path not found。 参数 -h 表示创建隐藏目录。 如果存在同名目录或文件，输出 file or directory with the same name exists。 4. find filename [-r] [-h] 查找目录或文件。 filename 应由两部分组成，前一部分是目录（为空就是当前目录），后一部分表示要查找的文件名（注意，这里表示在前一部分目录中寻找后一部分中的文件）。 前一部分目录应当是当前文件系统中存在的目录，否则输出 path not found。 -r 参数表示要查找的目录下的所有子目录都要查找。默认情况下，find 命令不会显示隐藏文件，（但是在有 -r 参数的情况下是会搜索隐藏子目录的），如果指定了 -h 参数，则会显示所有搜索到的隐藏文件。 如果没有找到需要输出的文件，则输出 file not found。否则对于找到的每个文件，输出单独的一行，按顺序会这样输出： 其中如果结果是隐藏或目录文件，则依次输出 hidden 和 dir。中间要有空格隔开。 结果应当按每个文件的绝对路径的字典序从小到大排序。 5. ls [path] [-h] [-r] [-s] [-S] [-f] [-d] 展示目录中文件。 总共 777 个可选参数，没有必选参数。 ls 展示方式与 find 相同。 path 指定展示的目录。若没有 path 选项，则制定当前目录为要展示的目录。 -h，-r 与 find 指令相同。 -s，-S 表示输出的顺序，-s 表示按照文件大小从小到大排序，-S 表示按照文件大小从大到小排序。如果没有制定其中任意一个参数，那么排序方式与 find 一样。又如果，两文件大小相同，那么也按照 find 的比较方式来排序。 比如说，如果没有指定 -s 和 -S 参数的结果是这样的： 那么指定了 -s 的参数排序如下： 指定了 -S 的参数排序如下： -f 表示只显示没有 directory 属性的文件； -d 表示只显示有 directory 属性的文件。 注意：两个参数可以同时出现。 6. pwd 输出当前目录的绝对路径。 7. exit 退出 Bash。 在本题中，表示初始化 Bash。 8. grep “string” 筛出输入字符串中含有 string 串的行。 在本题中，grep 只能通过管道调用。 何为管道？ 简单理解，就是将管道分隔符（|）前面的程序输出结果输入到后面的程序中。 比如说，假设 ls 命令当前是能够输出这些内容的： 如果我的命令是这样子的：ls | grep &quot;5&quot; 那么，grep 会筛取前面输入的字符串，并筛去不含 “5” 的行。 加上 grep 结果如下： 注意：管道可以叠加使用，只检查 string（不带有双引号）。 对于上面的结果，我们其实可以再添加一层 grep。 命令变为 ls | grep &quot;5&quot; | grep &quot; 5&quot;（注意后面的 grep 中有空格），那么输出就变成了： 由于在前一次 grep 结果中，第二行找不到 &quot; 5&quot;，所以，第二行被筛去了。 命令行中每一行包含一条或多条命令，用管道分隔符隔开（管道分隔符前后不一定有空格）。 第一条命令必须是除了 grep 之外的上述命令之一，而剩下的命令必须是 grep。 如果违反上述（上两行）中的规定，应输出 bad usage，并且不执行任何之后的命令（即之后的 grep）。 比如说： 输入保证满足以下条件： 每个命令的必选参数（如果有的话）都是第一个参数，可选参数在必选参数之后，但可能以任意顺序出现。 命令和参数，参数和参数之间保证有一个或多个空格。 用户不会忽略必选参数，不会使用非法参数，也不会在除了 grep 外的其他命令中使用引号。 如果第一条命令是 touch 或者 mkdir，且命令返回 bad usage，则不执行后面的命令（即 grep）。 模拟思路： 拆分命令和参数。 用一棵树来表示文件系统。 注意以格式化输出。 这里贴心的附上刘汝佳的代码 我的代码： "},{"title":"CF1260A Heating","date":"2022-07-29T07:56:23.000Z","url":"/2022/07/29/solution-cf1260a/","categories":[["undefined",""]],"content":"这是一道结论贪心题。结论简单，但是推倒的过程可能不止 入门。（个人感觉，可能有普及） 先说结论，对于每个 s(sum),cs(sum),cs(sum),c 都有答案 (s mod c)⌊sc+1⌋2+(c−s mod c)⌊sc⌋2(s\\bmod c)\\lfloor\\frac{s}{c}+1\\rfloor^2+(c-s\\bmod c)\\lfloor\\frac{s}{c}\\rfloor^2 (smodc)⌊cs​+1⌋2+(c−smodc)⌊cs​⌋2 但是如何得到呢？ 这就要有严谨的证明。 首先，看题目，将题面抽象出来，就是这样的： ans=min⁡{∑i=1cki2,∑i=1cki≥sum and k∈Z}ans=\\min\\Big\\{\\sum_{i=1}^{c}k_i^2,\\sum_{i=1}^{c} k_i\\geq sum\\ \\texttt{and}\\ k\\in Z\\Big\\} ans=min{i=1∑c​ki2​,i=1∑c​ki​≥sum and k∈Z} 形象化理解，就是把一个数分成 ccc 份，使分出来的数字的平方和最小。 于是，就按生活经验来判断，分成 ccc 份且平均的分配会有着更好的 ansansans。 首先，对同一个分的份数 kkk，证明，越平均的分配结果越小。 就等价于证： k(ak)2≤∑i=1kai2 (∑i=1kai=a,k∣a)k(\\frac{a}{k})^2\\leq \\sum_{i=1}^k a_i^2\\ \\ \\ \\ \\ \\ \\ \\ (\\sum_{i=1}^k a_i=a,k\\mid a) k(ka​)2≤i=1∑k​ai2​ (i=1∑k​ai​=a,k∣a) 证明过程如下： 先左右两边相减。 a2k−∑i=1kai2\\frac{a^2}{k}-\\sum^{k}_{i=1}a_i^2 ka2​−i=1∑k​ai2​ (∑i=1kai)2k−∑i=1kai2\\frac{(\\sum_{i=1}^k a_i)^2}{k}- \\sum_{i=1}^k a_i^2 k(∑i=1k​ai​)2​−i=1∑k​ai2​ ∑i=1kai2+∑i=1k−1∑j=i+1k2aiajk−∑i=1kai2\\frac{\\sum_{i=1}^k a_i^2+\\sum_{i=1}^{k-1}\\sum^{k}_{j=i+1}2a_ia_j}{k}-\\sum_{i=1}^k a_i^2 k∑i=1k​ai2​+∑i=1k−1​∑j=i+1k​2ai​aj​​−i=1∑k​ai2​ −(k−1)∑i=1kai2+∑i=1k−1∑j=i+1k2aiajk\\frac{-(k-1)\\sum_{i=1}^k a^2_i+\\sum_{i=1}^{k-1}\\sum^{k}_{j=i+1}2a_ia_j}{k} k−(k−1)∑i=1k​ai2​+∑i=1k−1​∑j=i+1k​2ai​aj​​ 重点！ −∑i=1k−1∑j=i+1k(ai−aj)2k\\frac{-\\sum_{i=1}^{k-1}\\sum^{k}_{j=i+1}(a_i-a_j)^2}{k} k−∑i=1k−1​∑j=i+1k​(ai​−aj​)2​ ∵−∑i=1k−1∑j=i+1k(ai−aj)2≤0,\\because -\\sum_{i=1}^{k-1}\\sum^{k}_{j=i+1}(a_i-a_j)^2\\leq 0, ∵−i=1∑k−1​j=i+1∑k​(ai​−aj​)2≤0, k&gt;0k&gt;0 k&gt;0 ∴−∑i=1k−1∑j=i+1k(ai−aj)2k≤0\\therefore \\frac{-\\sum_{i=1}^{k-1}\\sum^{k}_{j=i+1}(a_i-a_j)^2}{k}\\leq 0 ∴k−∑i=1k−1​∑j=i+1k​(ai​−aj​)2​≤0 ∴k(ak)2≤∑i=1kai2\\therefore k(\\frac{a}{k})^2\\leq \\sum_{i=1}^k a_i^2 ∴k(ka​)2≤i=1∑k​ai2​ 这就证明了在相同 kkk 之下，平均分配要比不平均优。 还有，kkk 越大，结果越优。 即证明： k1(ak1)2≤k2(ak2)2 (k1≤k2)k_1(\\frac{a}{k_1})^2\\leq k_2(\\frac{a}{k_2})^2\\ \\ \\ \\ \\ \\ \\ \\ (k_1\\leq k_2) k1​(k1​a​)2≤k2​(k2​a​)2 (k1​≤k2​) 证明是显然的。 所以分配越多越好。 所以，ccc 份全部分配，每一份越平均越好。 可能有读者注意到，前面的命题中，要求 k∣ak\\mid ak∣a。在本题中，这是不一定的。用鸽巢原理，将剩余的，也平均分到每一份当中。 所以， (s mod c)⌊sc+1⌋2+(c−s mod c)⌊sc⌋2(s\\bmod c)\\lfloor\\frac{s}{c}+1\\rfloor^2+(c-s\\bmod c)\\lfloor\\frac{s}{c}\\rfloor^2 (smodc)⌊cs​+1⌋2+(c−smodc)⌊cs​⌋2 的正确性就证明出来了。 上代码： "},{"title":"CF347A Difference Row","date":"2022-07-29T07:56:14.000Z","url":"/2022/07/29/solution-cf347a/","categories":[["undefined",""]],"content":"观察原序列， (x1−x2)+(x2−x3)+⋯+(xn−1−xn)(x_1-x_2)+(x_2-x_3)+\\cdots+(x_{n-1}-x_n) (x1​−x2​)+(x2​−x3​)+⋯+(xn−1​−xn​) 可以化简得到 x1−x2+x2−x3+⋯+xn−1−xnx_1-x_2+x_2-x_3+\\cdots+x_{n-1}-x_n x1​−x2​+x2​−x3​+⋯+xn−1​−xn​ 所以，抵消中间的项，可以得到最终式子为 x1−xnx_1-x_n x1​−xn​ 要让这个最大，直接让 x1=max⁡{xi},xn=min⁡{xi}x_1=\\max\\{x_i\\},x_n=\\min\\{x_i\\}x1​=max{xi​},xn​=min{xi​} 即可。 又要求按照字典序排列，那么排一遍序，最后交换首尾两个数字，就 ok 了。 "},{"title":"CF412A","date":"2022-07-29T07:56:06.000Z","url":"/2022/07/29/solution-cf412a/","categories":[["undefined",""]],"content":"很清晰的思路，就是向左再向右。 绘字符的时间是固定的，想要减少只能减少中间的搬梯子浪费的时间。 向左，为了一次性解决左边的字符，如果不是一直向左，那么中途必定向右，而左边还有未处理的字符，说明还需要返回，这时就浪费了两个小时；向右同理。所以，处理左右两边的字符，要么不处理，要么就直接处理完。 那么，先向左还是先向右呢？ 观察发现，先向左，那么中途浪费的时间就是左边节点数的两倍；先向右是右边节点数的两倍。自然是优先选择节点数少的了！ 那么，分类讨论，并整理模拟思路，就打出这样的代码： "},{"title":"Easy 的题 题解","date":"2022-07-29T07:55:59.000Z","url":"/2022/07/29/easy-problem-solution/","categories":[["undefined",""]],"content":"如题目名字，这是一道简单的题。观察式子， {∑ki≥0,(∑i=1nki)=k[k!∏i=1n(ki!)⋅∏i=1n(i!)ki]} mod p\\Big\\{\\sum_{k_i\\geq 0,(\\sum_{i=1}^n k_i)=k} \\Big[\\frac{k!}{\\prod_{i=1}^n(k_i!)}\\cdot\\prod_{i=1}^n(i!)^{k_i}\\Big]\\Big\\} \\bmod p {ki​≥0,(∑i=1n​ki​)=k∑​[∏i=1n​(ki​!)k!​⋅i=1∏n​(i!)ki​]}modp 就是 {∑ki≥0,(∑i=1nki)=k[(kk1,k2,⋯ ,kn)⋅∏i=1n(i!)ki]} mod p\\Big\\{\\sum_{k_i\\geq 0,(\\sum_{i=1}^n k_i)=k} \\Big[\\binom{k}{k_1,k_2,\\cdots,k_n}\\cdot\\prod_{i=1}^n(i!)^{k_i}\\Big]\\Big\\} \\bmod p {ki​≥0,(∑i=1n​ki​)=k∑​[(k1​,k2​,⋯,kn​k​)⋅i=1∏n​(i!)ki​]}modp 利用多项式定理可以化简得， (∑i=1n(i!))k mod p(\\sum_{i=1}^{n} (i!))^k\\bmod p (i=1∑n​(i!))kmodp 再把 mod \\bmodmod 搞进去，就成了这样： (∑i=1n(i! mod p))k mod p(\\sum_{i=1}^{n} (i!\\bmod p))^k\\bmod p (i=1∑n​(i!modp))kmodp 这时候，首先，时间复杂度可以变为 O(n2+k)O(n^2+k)O(n2+k)，此时可以拿到 303030 分。加上快速幂可以变为 O(n2+lg⁡k)O(n^2+\\lg k)O(n2+lgk)。 还有阶乘的递推关系可以降到 O(n+lg⁡k)O(n+\\lg k)O(n+lgk)。 现在解决如何处理 nnn。由于 n≤240n\\le 2^{40}n≤240，必须要优化。观察到当 i≥pi\\geq pi≥p 时，对式子的贡献为 000。所以，可以化为 (∑i=1min⁡{p−1,n}(i! mod p))k mod p(\\sum_{i=1}^{\\min\\{p-1,n\\}} (i!\\bmod p))^k\\bmod p (i=1∑min{p−1,n}​(i!modp))kmodp 此时最坏时间复杂度为 O(min⁡{p−1,n}+lg⁡k)O(\\min\\{p-1,n\\}+\\lg k)O(min{p−1,n}+lgk)。又因为 min⁡{p−1,n}≤107\\min\\{p-1,n\\}\\le 10^7min{p−1,n}≤107，可以咔过。 另外，因为只保证 min⁡{p−1,n}≤107\\min\\{p-1,n\\}\\le 10^7min{p−1,n}≤107，所以模数 ppp 可能 ≥107\\ge 10^7≥107，long long 会爆掉，只能用 __int128 或高精（ 所以，Solution： "},{"title":"键盘按键对应 ASCII 码记录","date":"2022-07-29T07:55:51.000Z","url":"/2022/07/29/jian-pan-an-jian-dui-ying-ascii-ma-ji-lu/","categories":[["undefined",""]],"content":"洛谷博客表格较为鬼畜，此文章将同步发表在 CSDN 上。 字母键及主键盘数字键 键名称 键代码 A ~ Z 65 ~ 90 0 ~ 9 和 ! ~ ) 48 ~ 57 小键盘数字及符号键 键名称 键代码 0 ~ 9 96 ~ 105 * 106 + 107 Enter 108 - 109 . 110 / 111 功能键 键名称 键代码 F1 ~ F12 112 ~ 123 双符号键 在主键盘，有上和下之分的符号。其中 a &amp;\\Large \\&amp;&amp; b 表示为符号 a 在下符号 b 在上（例 &lt; &amp;\\Large \\&amp;&amp; ,）。 键名称 键代码 ; &amp;\\Large \\&amp;&amp; : 186 = &amp;\\Large \\&amp;&amp; + 187 - &amp;\\Large \\&amp;&amp; _ 189 . &amp;\\Large \\&amp;&amp; &gt; 190 / &amp;\\Large \\&amp;&amp; ? 191 ` &amp;\\Large \\&amp;&amp; ~ 192 [ &amp;\\Large \\&amp;&amp; { 219 \\ &amp;\\Large \\&amp;&amp; | 220 ] &amp;\\Large \\&amp;&amp; } 221 控制键 键名称 键代码 BackSpace 8 Tab 9 Clear (?) 12 Enter 13 Shift 16 Ctrl 17 Alt 18 Caps Lock 20 Esc 27 SpaceBar（空格） 32 Page Up 33 Page Down 34 End 35 Home 36 Left Arrow 37 Up Arrow 38 Right Arrow 39 Down Arrow 40 Insert 45 Delete 46 NumLock 144 "},{"title":"模板大全","date":"2022-07-29T07:55:44.000Z","url":"/2022/07/29/mu-ban-tai-quan/","categories":[["undefined",""]],"content":"整理封装自 ryanright 的博客 高精度 ST 表 并查集 线段树 树状数组 普通平衡树 "},{"title":"CF1644A Doors and Keys 题解","date":"2022-07-29T07:55:36.000Z","url":"/2022/07/29/solution-cf1644a/","categories":[["undefined",""]],"content":" 题意简化 六个字母，任意一字母大写若出现在小写的前面，输出 NO，否则输出 YES。 Solution 字典暴力模拟，这样能够减少代码量。使用 toupper() 使代码更整洁。 "},{"title":"CF1644B Anti-Fibonacci Permutation 题解","date":"2022-07-29T07:55:29.000Z","url":"/2022/07/29/solution-cf1644b/","categories":[["undefined",""]],"content":"翻译已交，直接上正解。 Solution 显然，直接 dfs 生成排列-测试会超时。 想到可以在 dfs 过程中进行测试（判断下一个放置的数字是否满足反斐波那契序列的条件）。 于是代码就长这样： 46ms，AC。 But，你认为这就结束了吗？ Solution++ 以上方法时间复杂度玄学（不想算，反正有 O(n)O(n)O(n)，系数还蛮大），但通过数学分析可以降至裸 O(n)O(n)O(n)。并且代码量少很多 将排列降序。任意选择第 iii 位数，那么这个数就是 n−i+1n-i+1n−i+1。向前数两个数，分别是 n−i+2n-i+2n−i+2 和 n−i+3n-i+3n−i+3。显然，1≤i≤n1\\le i\\le n1≤i≤n。 将前两个数字相加，关于 iii 的方程 (n−i+3)+(n−i+2)=n−i+1(n-i+3)+(n-i+2)=n-i+1(n−i+3)+(n−i+2)=n−i+1 的解为 i=n+4i=n+4i=n+4。 若不是反斐波那契数列，就应该满足 i=n+4i=n+4i=n+4。与 1≤i≤n1\\le i\\le n1≤i≤n 相矛盾。说明逆序排列是反斐波那契数列。 那么，如果我们调换一下前后相邻的两个数的顺序？ 那么，序列就会变成： (n−i+4),(n−i+3),(n−i+1),(n−i+2),(n−i+0),(n−i−1) (n-i+4),(n-i+3),(n-i+1),(n-i+2),(n-i+0),(n-i-1) (n−i+4),(n−i+3),(n−i+1),(n−i+2),(n−i+0),(n−i−1) 事实上，可能没有 n−i−1n-i-1n−i−1，但没有可以不用管这个数字了，所以不会有问题。 如果有的话，调换顺序会波及到这些数字。 一一列出方程，解就完事了！ (n−i+4)+(n−i+3)=(n−i+1)(n-i+4)+(n-i+3)=(n-i+1)(n−i+4)+(n−i+3)=(n−i+1) i=n+3i=n+3i=n+3，不成立。 (n−i+3)+(n−i+1)=(n−i+2)(n-i+3)+(n-i+1)=(n-i+2)(n−i+3)+(n−i+1)=(n−i+2) i=n+2i=n+2i=n+2，不成立。 (n−i+1)+(n−i+2)=(n−i+0)(n-i+1)+(n-i+2)=(n-i+0)(n−i+1)+(n−i+2)=(n−i+0) i=n+3i=n+3i=n+3，不成立。 (n−i+2)+(n−i+0)=(n−i−1)(n-i+2)+(n-i+0)=(n-i-1)(n−i+2)+(n−i+0)=(n−i−1) i=n+3i=n+3i=n+3（想必你能猜到是这个吧），不成立。 都不成立，说明在倒序的基础上对调数字，都满足反斐波那契数列。 所以，总共可以调转 (n−1)(n-1)(n−1) 次，加上原来的逆序 111 次，就有 nnn 次了。 O(n)O(n)O(n) 满足了题目条件。 这也就为什么题目上会有 It can be shown that it is always possible to find n different anti-Fibonacci permutations of size n under the constraints of the problem.\\textsf{It can be shown that it is always possible to find n different anti-Fibonacci permutations of size n under the constraints of the problem.}It can be shown that it is always possible to find n different anti-Fibonacci permutations of size n under the constraints of the problem. 的原因吧。 附：中间为什么会有一个 i=n+2i=n+2i=n+2 的解呢？ 理性的认识，中间的两个数对调，移项了，所以有两点贡献，相比逆序的解应该少 222。 这下，其他的解为 i=n+3i=n+3i=n+3 应该也不难理解了吧。 Solution+∞\\infty∞ 事实上，这道题有许多方法，最终原理就是 逆序排列永远满足反斐波那契数列。 方法1 逆序后，将任意一个数提前，也是 (n−1)(n-1)(n−1) 种。 方法2 逆序后，调换间隔一个数的两个数。（猜测） ⋯⋯\\cdots\\cdots⋯⋯ 附上 Translate。 Translate 反斐波那契数列（anti-Fibonacci）定义为 1∼n1\\sim n1∼n 的排列中不满足 pi−2+pi−1≠pip_{i-2}+p_{i-1}\\ne p_ipi−2​+pi−1​​=pi​ 的排列。 输入 ttt 数据，每组数据给定序列长度 nnn。 对于每组数据，只需任意输出 nnn 个长度为 nnn 的反斐波那契数列。每行一个序列，用空格分隔。（不允许输出多个相同的序列。易证长度为 n(n≥3)n(n\\ge 3)n(n≥3) 的反斐波那契数列数量必定大于等于 nnn。） 其中 3≤n≤50,1≤t≤483\\le n\\le 50,1\\le t\\le 483≤n≤50,1≤t≤48。"},{"title":"CF1642A Hard Way 题解","date":"2022-07-29T07:55:21.000Z","url":"/2022/07/29/solution-cf1642a/","categories":[["undefined",""]],"content":" Solution 关于某一条线段是否是安全的（以下不考虑端点），有两个结论。 不是平行于 y=0y=0y=0 的线段必定是安全的； 若这条线段中较低的点（即 yyy 坐标较小的点）下方没有其他边，那么这条线段必定是安全的。 第二条结论显而易见，可以直接从三角形正下方的点通过直线到达。 第一条结论，斜着的线段无论多斜，我都可以从线段两侧中任意选择一侧的点到达。 如图，ABABAB 为原线段，延长 ABABAB 至 DDD 交 xxx 轴于 DDD。在 DDD 左侧任意找一点 EEE 都可以通过直线到达 ABABAB 上的点 (C)(C)(C)。 结合下两个结论，只有一种可能有不安全的线段。即： 一个三角形中，有一条线段平行于 y=0y=0y=0，并且还是三角形较高的边。 比如样例第三组数据， 就是符合这些要求的三角形。 解法已经有了，如何更好的写更简单的代码呢？ 用 struct 存端点，用 sort 简化代码。 code 我有一个小疑问，题目中对浮点误差的处理有何意义？反正都是整数"},{"title":"Codeforces Round 774","date":"2022-07-29T07:55:14.000Z","url":"/2022/07/29/774-solution/","categories":[["undefined",""]],"content":" A. Square Counting 给你一个序列 a1,⋯ ,an+1a_1,\\cdots,a_{n+1}a1​,⋯,an+1​，每一个元素满足两个条件： 0≤ai&lt;n0\\le a_i&lt;n0≤ai​&lt;n ai=n2a_i=n^2ai​=n2 已知 nnn 和序列之和 sss，求对于任意 1≤i≤n+11\\le i\\le n+11≤i≤n+1，ai=n2a_i=n^2ai​=n2 的个数。 ttt 组数据。 可以证明结果唯一。 结论： ans=⌊s/n2⌋ans=\\lfloor s/n^2\\rfloorans=⌊s/n2⌋ 题目中，首先看到了 结果唯一。所以证明的起点就在这里。 因为 [0,n)[0,n)[0,n) 范围内的数至多有 (n+1)(n+1)(n+1) 个，最小总值为 000，最大总值为 n2−1n^2-1n2−1，所以数列中的 n2n^2n2 不能被 [0,n)[0,n)[0,n) 范围内的数代替，因此答案唯一。 B. Quality vs Quantity 涂色问题。有一个序列 a1,⋯ ,ana_1,\\cdots,a_na1​,⋯,an​，可以有三种状态：标记为红色，标记为蓝色，不标记颜色。 设标记红色的元素集合为 RRR，绿色为 BBB。 那么，是否能够满足 ∑x∈Rx&gt;∑x∈Bx\\sum_{x\\in R}x&gt;\\sum_{x\\in B}x x∈R∑​x&gt;x∈B∑​x 且 ∣R∣&lt;∣B∣|R|&lt;|B|∣R∣&lt;∣B∣？ 能输出 YES，不能输出 NO。（虽然输出 yEs 和 YeS 是一样的） 贪心。想要 RRR 和大于 BBB 和，而且 RRR 数量还得更少，那么只能让 RRR 中的元素远远大于 BBB 中元素。 那么排一遍升序，从左到右选，左边选 xxx 个数当做 BBB，右边选择 (x+1)(x+1)(x+1) 个数当做 RRR，如果扫完全序列都不能满足，那必然是 nO 了。 单次 O(nlog⁡n)O(n\\log n)O(nlogn)，均摊总时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 C. Factorials and Powers of Two 称一个数为强数，当且仅当这个数为 2d2^d2d 或 d!d!d!，其中 d∈Nd\\in Nd∈N。（NNN 为非负整数集合） 求一个数最最少可以被分解为多个强数之和？ 如果不可以被分解，那么输出 −1-1−1。 首先，−1-1−1 是不可能的。因为任意一个非负整数都可以转换成对应的二进制。而对应二进制位上的 111，单独拿出来，就都是强数。 比如 7=(111)2=1×20+1×21+1×227=(111)_2=1\\times2^0+1\\times2^1+1\\times2^27=(111)2​=1×20+1×21+1×22。 那么，现在就想，如何使 kkk（即分解个数）最小了。 若直接枚举强数相加，那么时间复杂度为 2(log⁡21e12+16)2^{(\\log_2 1e12+16)}2(log2​1e12+16)。比较危险。 但是，发现只要确定阶乘的强数，反过来就可以推出二次幂的强数个数。 所以，可以只枚举 2162^{16}216 次就可以了。 （161616 来自何方？1e121e121e12 的逆阶乘小于等于 161616。） "},{"title":"Codeforces Round 775","date":"2022-07-29T07:55:06.000Z","url":"/2022/07/29/775-solution/","categories":[["undefined",""]],"content":" A. Game 有 nnn 个横向排列的位置，序号为 1∼n1\\sim n1∼n，每个位置可能有水，也可能是空的。 向相邻格子移动是不需要花费的。 在每组数据中，你只能跳一次。你可以跳任意格远。代价为 ∣dj−di∣|d_j-d_i|∣dj​−di​∣（jjj 为终点 iii 为起点） 你不能跳到含水格子里。保证起点 111 和终点 nnn 没有水。 只能跳一次，那么说明我们只可能通过一次大跳来跳过所有含水格子。大跳的代价与距离成正比，所以大跳的距离越小越好。 那么，大跳就从最左边的水格子前起跳，跳到最右边的水格子后即可。 B. Game of Ball Passing 传球游戏。在游戏的过程中，有 nnn 个人。他们将要互相传球。每个人传出球的次数是给定的（传入不算次数）。 那么，最少需要多少个球可以满足这些传球的次数呢？ 比如说，第一组样例就可以只用一个球传出这种方案。 而第二组样例则不行。 重点在于如何利用 “每个人传出球的次数是给定的（传入不算次数）。” 找出踢球数最大的人，这个人的踢球数可以消耗其他人的踢球数。 若其他人的踢球数总和大于踢球数的人，这些人可以自己内部对踢（无论是一对一还是多对多，反正剩下的踢球数等于最大踢球数）。 但如果最大踢球数的人踢球的数量太大了，他跟其他人消耗后，还剩下了一些球数，只能他自己踢了（为什么？最多的情况下，即剩下人不内部踢球，只与最大踢球数的人踢，也只能消耗这些，还差一些）。 所以， "},{"title":"Codeforces Round 776","date":"2022-07-29T07:54:59.000Z","url":"/2022/07/29/776-solution/","categories":[["undefined",""]],"content":" A. Deletions of Two Adjacent Letters 一个字符串，长度为奇数（长度不大于 494949），只可以在其中删除连续的两个字符。问是否能使删剩下的字符（必须删到一个字符）为给定字符？ 能则输出 YES，不能则输出 NO。 如果这个字符处在偶数位上，那么他的左边或者右边就都有奇数个字符，不可能通过删去连续的两个字符来留下这个字符（左右不能跨分界线删除）。 注意同一个字符可能出现多次。模拟即可。 B. DIV + MOD 定义函数 fa(x)=⌊xa⌋+x mod af_a(x)=\\lfloor\\frac{x}{a}\\rfloor+x\\bmod afa​(x)=⌊ax​⌋+xmoda，其中 aaa 为系数。 给定系数 aaa，给定 xxx 范围 l≤x≤rl\\le x\\le rl≤x≤r，求 fa(x)f_a(x)fa​(x) 在范围内值的最大值。 其中 1≤l≤r≤1091\\le l\\le r\\le 10^91≤l≤r≤109，1≤a≤1091\\le a\\le 10^91≤a≤109。 显然在范围区间内变化大的是右边的 x mod ax\\bmod axmoda（为什么？）。 但也会出现 ⌊xa⌋\\lfloor\\frac{x}{a}\\rfloor⌊ax​⌋ 变化的情况。那么，最大值就有两种情况了（即两个大幅度的变化区间，下见图片）： 在小于等于 rrr 的数中除以 aaa 的余数最大。 数 rrr。 那么，若存在情况 1，则取最大值。若不存在，直接取情况 2 即可。 C. Weight of the System of Nested Segments 在一个数轴上，有一些整点。称一些数为 包含系统 ，当这些坐标配对 (xl,xr)(x_l,x_r)(xl​,xr​)时，任意 i&lt;ji&lt;ji&lt;j 有 li&lt;lj&lt;rj&lt;rll_i&lt;l_j&lt;r_j&lt;r_lli​&lt;lj​&lt;rj​&lt;rl​。 共有 mmm 个点，取出其中 2n2n2n 个点，使得这些数配对 nnn 组后代价和最小。 一个配对的代价为 wl+wrw_l+w_rwl​+wr​。 给出每个点的坐标 xxx 和代价 www。求最小代价和和匹配数字的序号（序号就是输入的顺序，从 111 开始）。 ∑n\\sum n∑n 不超过 2×1052\\times 10^52×105。 只要取出 2n2n2n 个点，都可以说明这些点可以配对（从左到右，从右到左依次配对）。 所以，我们只需要以代价排一遍序，左边取 2n2n2n 个数，再以坐标为关键字排序配对即可。 "},{"title":"CF1650A Solution","date":"2022-07-29T07:54:51.000Z","url":"/2022/07/29/solution-cf1650a/","categories":[["undefined",""]],"content":" Solution 如果这个字符处在偶数位上，那么他的左边或者右边就都有奇数个字符，不可能通过删去连续的两个字符来留下这个字符（左右不能跨分界线删除）。 注意同一个字符可能出现多次。模拟即可。 "},{"title":"CF1650B Solution","date":"2022-07-29T07:54:44.000Z","url":"/2022/07/29/solution-cf1650b/","categories":[["undefined",""]],"content":" Solution 显然在范围区间内变化大的是右边的 x mod ax\\bmod axmoda（为什么？）。 但也会出现 ⌊xa⌋\\lfloor\\frac{x}{a}\\rfloor⌊ax​⌋ 变化的情况。那么，最大值就有两种情况了（即两个大幅度的变化区间，下见图片）： 在小于等于 rrr 的数中除以 aaa 的余数最大。 数 rrr。 那么，若存在情况 1，则取最大值。若不存在，直接取情况 2 即可。 "},{"title":"CF1650C Solution","date":"2022-07-29T07:54:36.000Z","url":"/2022/07/29/solution-cf1650c/","categories":[["undefined",""]],"content":" Solution 只要取出 2n2n2n 个点，都可以说明这些点可以配对（从左到右，从右到左依次配对）。 所以，我们只需要以代价排一遍序，左边取 2n2n2n 个数，再以坐标为关键字排序配对即可。 "},{"title":"CF1649A Solution","date":"2022-07-29T07:54:29.000Z","url":"/2022/07/29/solution-cf1649a/","categories":[["undefined",""]],"content":" Solution 只能跳一次，那么说明我们只可能通过一次大跳来跳过所有含水格子。大跳的代价与距离成正比，所以大跳的距离越小越好。 那么，大跳就从最左边的水格子前起跳，跳到最右边的水格子后即可。 "},{"title":"CF1649B Solution","date":"2022-07-29T07:54:21.000Z","url":"/2022/07/29/solution-cf1649b/","categories":[["undefined",""]],"content":" Solution 重点在于如何利用 “每个人传出球的次数是给定的（传入不算次数）。” 找出踢球数最大的人，这个人的踢球数可以消耗其他人的踢球数。 若其他人的踢球数总和大于踢球数的人，这些人可以自己内部对踢（无论是一对一还是多对多，反正剩下的踢球数等于最大踢球数）。 但如果最大踢球数的人踢球的数量太大了，他跟其他人消耗后，还剩下了一些球数，只能他自己踢了（为什么？最多的情况下，即剩下人不内部踢球，只与最大踢球数的人踢，也只能消耗这些，还差一些）。 所以， "},{"title":"CF1646A Solution","date":"2022-07-29T07:54:14.000Z","url":"/2022/07/29/solution-cf1646a/","categories":[["undefined",""]],"content":" Solution 结论： ans=⌊s/n2⌋ans=\\lfloor s/n^2\\rfloorans=⌊s/n2⌋ 题目中，首先看到了 结果唯一。所以证明的起点就在这里。 因为 [0,n)[0,n)[0,n) 范围内的数至多有 (n+1)(n+1)(n+1) 个，最小总值为 000，最大总值为 n2−1n^2-1n2−1，所以数列中的 n2n^2n2 不能被 [0,n)[0,n)[0,n) 范围内的数代替，因此答案唯一。 "},{"title":"CF1646B Solution","date":"2022-07-29T07:54:06.000Z","url":"/2022/07/29/solution-cf1646b/","categories":[["undefined",""]],"content":" Solution 贪心。想要 RRR 和大于 BBB 和，而且 RRR 数量还得更少，那么只能让 RRR 中的元素远远大于 BBB 中元素。 那么排一遍升序，从左到右选，左边选 xxx 个数当做 BBB，右边选择 (x+1)(x+1)(x+1) 个数当做 RRR，如果扫完全序列都不能满足，那必然是 nO 了。 单次 O(nlog⁡n)O(n\\log n)O(nlogn)，均摊总时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 "},{"title":"CF1646C Solution","date":"2022-07-29T07:53:59.000Z","url":"/2022/07/29/solution-cf1646c/","categories":[["undefined",""]],"content":" Solution 首先，−1-1−1 是不可能的。因为任意一个非负整数都可以转换成对应的二进制。而对应二进制位上的 111，单独拿出来，就都是强数。 比如 7=(111)2=1×20+1×21+1×227=(111)_2=1\\times2^0+1\\times2^1+1\\times2^27=(111)2​=1×20+1×21+1×22。 那么，现在就想，如何使 kkk（即分解个数）最小了。 若直接枚举强数相加，那么时间复杂度为 2(log⁡21012+16)2^{(\\log_2 10^{12}+16)}2(log2​1012+16)。比较危险。 但是，发现只要确定阶乘的强数，反过来就可以推出二次幂的强数个数。 所以，可以只枚举 2162^{16}216 次就可以了。 （161616 来自何方？101210^{12}1012 的逆阶乘小于等于 161616。） "},{"title":"CF1651A Playoff Solution","date":"2022-07-29T07:53:51.000Z","url":"/2022/07/29/solution-cf1651a/","categories":[["undefined",""]],"content":" Transplate 1∼2n1\\sim 2^n1∼2n 这些数将进行淘汰赛。规则如下。 第一轮比赛由相邻两个数比较。即 (1,2),(3,4),⋯(1,2),(3,4),\\cdots(1,2),(3,4),⋯。 之后比赛由上一轮比赛的胜出者进行比赛。 两个数加和若为奇数，那么小的数胜利；若为偶数，那么大的数胜利。 问最终留下来的数是哪个数？ Solution 第一轮比赛，留下来的数都是奇数。 （为什么？第一轮加和都为奇数，而较小的数都是偶数） 之后每一轮的比赛留下来的都是较大的数。 （为什么？奇数相加都是偶数，所以大的数赢） 那么，最终留下来的就是数列中最大的奇数：2n−12^n-12n−1。 "},{"title":"CF1651B Prove Him Wrong Solution","date":"2022-07-29T07:53:44.000Z","url":"/2022/07/29/solution-cf1651b/","categories":[["undefined",""]],"content":" Solution 题目要求对于任意 i,ji,ji,j 都要满足 ai+aj≤2⋅∣ai−aj∣a_i+a_j\\le 2\\cdot|a_i-a_j|ai​+aj​≤2⋅∣ai​−aj​∣。 有绝对值，不妨 ai≤aja_i\\le a_jai​≤aj​。所以有 ai+aj≤2⋅(aj−ai)a_i+a_j\\le 2\\cdot(a_j-a_i) ai​+aj​≤2⋅(aj​−ai​) 解得 3⋅ai≤aj3\\cdot a_i\\le a_j 3⋅ai​≤aj​ 所以只要让数等于前面那个数的三倍即可。初始数为 111。（升序，对于任意 i,ji,ji,j 都满足，因为是绝对值对称的） 注意到，样例中有输出 NO 的情况。是什么原因呢？ 题目中有限制 ai≤109a_i\\le10^9ai​≤109。实际上最大的数应该是 3n−13^{n-1}3n−1。所以 3n−1≤1093^{n-1}\\le10^93n−1≤109， n−1≤log⁡3109n-1\\le \\log_310^9 n−1≤log3​109 即 n≤19n\\le19 n≤19 那么 Code 长这样： "},{"title":"CF1654A Solution","date":"2022-07-29T07:53:36.000Z","url":"/2022/07/29/solution-cf1654a/","categories":[["undefined",""]],"content":" Solution 发现只要选择任意两个数，都可以通过一次操作将他们两个放在相邻的地方。 若设处理的两个数为 axa_xax​ 和 aya_yay​， 如果 x&lt;y−1x&lt;y-1x&lt;y−1，只要翻转 [x,y−1][x,y-1][x,y−1] 即可。 如果 x&gt;y+1x&gt;y+1x&gt;y+1，只要翻转 [y+1,x][y+1,x][y+1,x] 即可。 那么，只要找到序列中最大的两个数，加和输出即可。 时 O(∑n)O(\\sum n)O(∑n)，空 O(1)O(1)O(1)。 "},{"title":"CF1654B Solution","date":"2022-07-29T07:53:29.000Z","url":"/2022/07/29/solution-cf1654b/","categories":[["undefined",""]],"content":" Solution 初看这道题，诶，有点难度，果然是 Div.1 + Div.2 的难度啊，AC 自动机？ 啊不不不，完全可以不用 AC 自动机。 可以发现，只需要查找第一个字母是否出现在后面即可。 设字符串为 si (1≤i≤∣s∣)s_i\\ (1\\le i\\le |s|)si​ (1≤i≤∣s∣) 。 如果 s1⋯sks_1\\cdots s_ks1​⋯sk​ 在后面出现过，那么发现 s1s_1s1​ 实际上也会在后面出现。 实际上 s2⋯sks_2\\cdots s_ks2​⋯sk​ 也都出现。（虽然都是废话） 所以只需要依次删除字符串的第一个字符，只要在后面找到，就说明这个字符必定是在当前最长前缀里头的，且之后的字符都可以依次删除。 那么， 时 O(∑∣s∣)O(\\sum|s|)O(∑∣s∣)，空 O(∣s∣)O(|s|)O(∣s∣)。 "},{"title":"CF1654C Solution","date":"2022-07-29T07:53:21.000Z","url":"/2022/07/29/solution-cf1654c/","categories":[["undefined",""]],"content":" Solution 暴 力 是不可能不打的。 这道题目有两种暴力方法。 一种从合并角度看，将相邻的两个数依次合并，看是否能合并完成。 但我选择的是更直观的暴力打法。 将总和依次分解，想到每一次的分解结果要是有对应的数字就消掉，剩下的分解，那么用 map 维护当前还需要处理的对应数字，一个 bfs 可以解决。 请注意，若分解个数大于 nnn 次后，必然是有些数字分解不了，那么这时候直接 return，以减小空间 &amp; 时间。如果不处理会 TLE。 空间 O(n)O(n)O(n)，时间 O(nlog⁡n)O(n\\log n)O(nlogn)。 "},{"title":"P8102 Cow Insertion Solution","date":"2022-07-29T07:53:14.000Z","url":"/2022/07/29/solution-p8102/","categories":[["undefined",""]],"content":"听着《打上花火》，不知不觉推出了式子 初碰此题，看见 n≤5×106n \\le 5 \\times 10^6n≤5×106，感觉 nlg⁡nn \\lg nnlgn 能过啊 （5×106×lg⁡5×106≈5×106×22.2534≈1.1126×1085\\times 10^6 \\times \\lg5\\times10^6 \\approx 5\\times10^6 \\times 22.2534 \\approx 1.1126 \\times 10^85×106×lg5×106≈5×106×22.2534≈1.1126×108） 心想可能得卡个常数了（事实后来我是大常数选手） 看到题面立马想到插入 AAA 的影响是有限的，大概是向左向右 mmm 个数。 整个题目都在求 max⁡xy\\max_x^ymaxxy​，干脆将所有 max⁡\\maxmax 得到的数单独算出来。想到算定长最值，可以用 滑动窗口 O(n)O(n)O(n) 解决，所以将值设出来： si=max⁡j=ii+m−1aj (1≤i≤n−m+1)s_i = \\max _ {j = i} ^ {i + m - 1} a_j \\ (1 \\le i \\le n - m + 1) si​=j=imaxi+m−1​aj​ (1≤i≤n−m+1) 那么未插入 AAA 的答案即为： ans1=∑i=1n−m+1sians_1 = \\sum _ {i = 1} ^ {n - m + 1} s_i ans1​=i=1∑n−m+1​si​ 现在考虑插入 AAA 之后答案将会变成什么。 如果将 AAA 插入到 aka_kak​ 后面，序列长这个样子： ⋯ ,ak,A,ak+1,⋯\\cdots, a_k, A, a_k +1, \\cdots ⋯,ak​,A,ak​+1,⋯ 那么左端没有覆盖到 AAA 的地方是不会受 AAA 的影响的。 有右边界 i+m−1=ki + m - 1 = ki+m−1=k（sis_isi​ 的右端点刚好与 aka_kak​ 重合） 所以右边界为 i=k−m+1i = k - m + 1i=k−m+1。 所以左端未受影响的答案为 ans2=∑i=1k−m+1sians_2 = \\sum _ {i = 1} ^ {k - m + 1} s_i ans2​=i=1∑k−m+1​si​ 同理， 右端左边界 i=k+1i = k + 1i=k+1， 则右端未受影响的答案为 ans3=∑i=k+1n−m+1sians_3 = \\sum _ {i = k + 1} ^ {n - m + 1} s_i ans3​=i=k+1∑n−m+1​si​ 现在需要处理中间受影响的部分。 观察到覆盖 AAA 的地方有个共同点，就是他们对答案的贡献为原长度为 m−1m - 1m−1 的贡献与 AAA 取 max⁡\\maxmax。 将长度为 m−1m - 1m−1 的 max⁡\\maxmax 结果列出来： ui=max⁡j=ii+m−2aj (1≤i≤n−m+2)u_i = \\max _ {j = i} ^ {i + m - 2} a_j \\ (1 \\le i \\le n - m + 2) ui​=j=imaxi+m−2​aj​ (1≤i≤n−m+2) uiu_iui​ 与 sis_isi​ 相似。 那么，ai,⋯ ,ak,A,ak+1,⋯ ,ai+m−2a_i, \\cdots, a_k, A, a_{k + 1}, \\cdots, a_{i + m - 2}ai​,⋯,ak​,A,ak+1​,⋯,ai+m−2​ 的最终贡献为 max⁡{A,ui}\\max\\{A, u_i\\} max{A,ui​} 左边界为 i+m−2=ki + m - 2 = ki+m−2=k（刚好 AAA 踩到原来 k+1k + 1k+1 的位置） 所以 i=k−m+2i = k - m + 2i=k−m+2。 右边界同理，i=k+1i = k + 1i=k+1。 所以贡献为： ans4=∑i=k−m+2k+1max⁡{A,ui}ans_4 = \\sum _ {i = k - m + 2} ^ {k + 1} \\max\\{A, u _ i\\} ans4​=i=k−m+2∑k+1​max{A,ui​} 所以加入 AAA 的最终答案为： ans′=ans2+ans4+ans3ans&#x27; = ans _ 2 + ans _ 4 + ans _3 ans′=ans2​+ans4​+ans3​ 即 ans′=∑i=1k−m+1si+∑i=k−m+2k+1max⁡{A,ui}+∑i=k+1n−m+1sians&#x27; = \\sum _ {i = 1} ^ {k - m + 1} s_i + \\sum _ {i = k - m + 2} ^ {k + 1} \\max\\{A, u _ i\\} + \\sum _ {i = k + 1} ^ {n - m + 1} s_i ans′=i=1∑k−m+1​si​+i=k−m+2∑k+1​max{A,ui​}+i=k+1∑n−m+1​si​ 此时可以直接通过求出 sss 即 uuu（需要先进行 max⁡\\maxmax 操作）的前缀和，O(n)×O(1)O(n) \\times O(1)O(n)×O(1) 枚举求解 ans′ans&#x27;ans′。 但是，式子有点乱。 将 ans′−ansans&#x27; - ansans′−ans，得到加入 AAA 的贡献： ans′′=ans′−ans=∑i=k−m+2k+1max⁡{A,ui}−∑i=k−m+2ksians&#x27;&#x27; = ans&#x27; - ans = \\sum _ {i = k - m + 2} ^ {k + 1} \\max\\{A, u _ i\\} - \\sum _ {i = k - m + 2} ^ {k} s _ i ans′′=ans′−ans=i=k−m+2∑k+1​max{A,ui​}−i=k−m+2∑k​si​ 于是可以得到一个用 std::vector 实现的超大常数 code： "},{"title":"我所保存的链接","date":"2022-07-29T07:53:06.000Z","url":"/2022/07/29/wo-suo-bao-cun-di-lian-jie/","categories":[["undefined",""]],"content":" 2022/6/16 Kth-Number-BFPRT-zhihu Kth-Number-BFPRT 2021/12/29 OpenSSH-Github"}]